---
description: IDA, instructions, opfuncions
---

# RE debugging

## Static vs. Dynamic

* combine both of them
  * each has pros/cons
* dynamic -> quick idea about malwareÂ´s functionality and to extract some IOCs
  * debugging in VM env (security)
* static -> offers in depth knowledge to reveal more IOCs
* we can create mind map also

## Disassemblers

### IDA

* Interactive disassembler + has also decompiler (additional money for license)
* "The industry standard"
* Supports multiple executable formats and architectures
  * PE, ELF, Mach-O
  * x86, x64, ARM
  * BIOS, UEFI
  * etc
* not good for .NET apps
* Shortcuts
  * G - jump to address
  * X - display references to var/func
  * CTRL+E - display EntryPoints
  * SHIFT+F12 - display strings
  * N - rename var/func
  * ESC - go back
  * M - chooose constant name for var.value
  * R - convert value to ASCII
  * H - convert Hex to Decimal and back

#### Architecture

* Kernel -> Plugins (we can write our own)
* Kernel -> DB (after creating procejt in IDA, it creates about 6 DB files)
  * we can send only DB files to colleagues, not all the project in IDA
* Kernel -> GUI
* Kernel -> Input File Loader
* Kernel -> Processor module

<figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption><p>IDA Pro architecture</p></figcaption></figure>

#### Interface

* First opening IDA Pro -> File loader module
  * displays info about the file, processor type and other options
  * we can leave it as default
* Please confirm window
  * some PEs have also PDB metadata (generated during compiling process)
    * press No since we dont have the PDB file
    * press Yes since it is a Microsoft binary

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption><p>Ida Interface</p></figcaption></figure>

* Views
  * code -> right-click -> synchronize (it colours the given line of code in all views)
  * HexEditor view
  * Structure view
  * Decimpiler view
  * Imports view
  * Strings view
  * Console view
  * Others...

## Introduction

### Programming lang generations

* 1+2 -> Low level
* 3+4+5 -> High level
* 1.gen -> Binary Machine code
  * 1940-1956
  * Can understand only binary code (0/1)
  * Examples: binary digits/bits
* 2.gen -> Assembly code
  * 1956-1963
  * Examples:&#x20;
  * Usage: microprocessors (transistors), kernels, HW drivers
  * PC needs:
    * ASSEMBLER to translate into machine code
* 3.gen -> Block structured code
  * 1964-1971
  * Examples: C, C++, Java, Pascal, FORTRAN, COBOL, JavaScript
  * Upgrade: English-like words, lesser lines of code, can copy the code to another machine
  * PC needs:
    * COMPILER to translate into assembly code&#x20;
    * ASSEMBLER to translate into machine code
* 4.gen -> OOP (Object oriented programming lang)
  * 1971-now
  * Usage: DBs, scripting
  * Examples: Python, SQL, Ruby, Perl
  * Upgrade: Easier to understand, less time for creation, BUT higher memory consumption, poor control over HW
  * PC needs:
    * COMPILER to translate into assembly code&#x20;
    * ASSEMBLER to translate into machine code
* 5.gen -> Natural Language Processing
  * now
  * They have visual tools to develop a program
  * Examples: Prolog, Mercury, OPS5
  * Upgrade: machine can make decisions, easier to use, BUT complex and long code, a lot of HW needed
  * Usage: Deepl, AI

<figure><img src=".gitbook/assets/image (3).png" alt=""><figcaption><p>Programming language hierarchy [<a href="https://medium.com/@ajuatahcodingarena/generations-of-programming-languages-bed30d19ea8e">https://medium.com/@ajuatahcodingarena/generations-of-programming-languages-bed30d19ea8e</a>]</p></figcaption></figure>

### Compilation process

* Compiling -> process of converting source code into object code
* Compiler -> program responsible for this operation
* Compiler breaks the process in 4 stages (+5. loader/execute in OS):
  * preprocessor (hello.cpp file) (hello.i)
    * source code
  * compiler (hello.s)
    * expanded code
  * assembler (hello.obj)
    * assembly code
  * linker (PE file - hello.exe)
    * object code
  * loader/execute (process execution)

### Disassembly and Decompilation process

* RE requires reversing the previously described operations
* compilation is lossy -> we need to determine ourselves the var/func types and names
* each compiler uses different optimizations and translation techniques, thus compilind and DEcompiling will NOT result in the same source code...

### Goals and Objectives of RE SW

* facilitate understanding of programs when source code is not available...
  * malware analysis
  * vuln research
  * compiler validaton

## Interface Excercire #1

* ca0d1e....b8dd53
  * open the executable in IDA and use the default loading settings
  * switch between "graph-view" and "text-view"
  * navigate through the "function windows" and find the main function
  * How many imports and exports does the executable have?
  * Open the Strings windows and configure it to display all string types
  * How many strings has IDA identified?
  * Open the decompiler and jump to the main function
  * Open the segments window - how many sections does the binary have?
  * What are the section names?
  * Close IDA, dont save DB

## Interface Excercire #2

* ca0d1e....b8dd53
  * Enable the line prefixes (address) for the graph view and auto-comments
  * Display 6 byte opcodes
  * Jump to address 0x00404A00:
    * How many local vars and args does this func have?
    * How many times is this func used in the code?
    * Jump to some of the referenced locations, what can you say about the args?
    * Rename the function to something meaningful
  * Go to address 0x005D8028 and define the data as a ASCII string
