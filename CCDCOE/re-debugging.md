---
description: IDA, instructions, opfuncions
---

# RE debugging

## Static vs. Dynamic

* combine both of them
  * each has pros/cons
* dynamic -> quick idea about malwareÂ´s functionality and to extract some IOCs
  * debugging in VM env (security)
* static -> offers in depth knowledge to reveal more IOCs
* we can create mind map also

## Disassemblers

### IDA

* Interactive disassembler + has also decompiler (additional money for license)
* "The industry standard"
* Supports multiple executable formats and architectures
  * PE, ELF, Mach-O
  * x86, x64, ARM
  * BIOS, UEFI
  * etc
* not good for .NET apps
* doesnt work with YARA
* Shortcuts
  * G - jump to address
  * X - display references to var/func
  * CTRL+E - display EntryPoints
  * SHIFT+F12 - display strings
  * N - rename var/func
  * ESC - go back
  * M - chooose constant name for var.value
  * R - convert value to ASCII
  * H - convert Hex to Decimal and back

#### Architecture

* Kernel -> Plugins (we can write our own)
* Kernel -> DB (after creating procejt in IDA, it creates about 6 DB files)
  * we can send only DB files to colleagues, not all the project in IDA
* Kernel -> GUI
* Kernel -> Input File Loader
* Kernel -> Processor module

<figure><img src=".gitbook/assets/image (2) (1).png" alt=""><figcaption><p>IDA Pro architecture</p></figcaption></figure>

#### Interface

* First opening IDA Pro -> File loader module
  * displays info about the file, processor type and other options
  * we can leave it as default
* Please confirm window
  * some PEs have also PDB metadata (generated during compiling process)
    * press No since we dont have the PDB file
    * press Yes since it is a Microsoft binary

<figure><img src=".gitbook/assets/image (1) (1).png" alt=""><figcaption><p>Ida Interface</p></figcaption></figure>

* Views
  * code -> right-click -> synchronize (it colours the given line of code in all views)
  * HexEditor view
  * Structure view
  * Decimpiler view
  * Imports view
  * Strings view
  * Console view
  * Others...

## Introduction

### Programming lang generations

* 1+2 -> Low level
* 3+4+5 -> High level
* 1.gen -> Binary Machine code
  * 1940-1956
  * Can understand only binary code (0/1)
  * Examples: binary digits/bits
* 2.gen -> Assembly code
  * 1956-1963
  * Examples:&#x20;
  * Usage: microprocessors (transistors), kernels, HW drivers
  * PC needs:
    * ASSEMBLER to translate into machine code
* 3.gen -> Block structured code
  * 1964-1971
  * Examples: C, C++, Java, Pascal, FORTRAN, COBOL, JavaScript
  * Upgrade: English-like words, lesser lines of code, can copy the code to another machine
  * PC needs:
    * COMPILER to translate into assembly code&#x20;
    * ASSEMBLER to translate into machine code
* 4.gen -> OOP (Object oriented programming lang)
  * 1971-now
  * Usage: DBs, scripting
  * Examples: Python, SQL, Ruby, Perl
  * Upgrade: Easier to understand, less time for creation, BUT higher memory consumption, poor control over HW
  * PC needs:
    * COMPILER to translate into assembly code&#x20;
    * ASSEMBLER to translate into machine code
* 5.gen -> Natural Language Processing
  * now
  * They have visual tools to develop a program
  * Examples: Prolog, Mercury, OPS5
  * Upgrade: machine can make decisions, easier to use, BUT complex and long code, a lot of HW needed
  * Usage: Deepl, AI

<figure><img src=".gitbook/assets/image (3) (1).png" alt=""><figcaption><p>Programming language hierarchy [<a href="https://medium.com/@ajuatahcodingarena/generations-of-programming-languages-bed30d19ea8e">https://medium.com/@ajuatahcodingarena/generations-of-programming-languages-bed30d19ea8e</a>]</p></figcaption></figure>

### Compilation process

* Compiling -> process of converting source code into object code
* Compiler -> program responsible for this operation
* Compiler breaks the process in 4 stages (+5. loader/execute in OS):
  * preprocessor (hello.cpp file) (hello.i)
    * source code
  * compiler (hello.s)
    * expanded code
  * assembler (hello.obj)
    * assembly code
  * linker (PE file - hello.exe)
    * object code
  * loader/execute (process execution)

### Disassembly and Decompilation process

* RE requires reversing the previously described operations
* compilation is lossy -> we need to determine ourselves the var/func types and names
* each compiler uses different optimizations and translation techniques, thus compilind and DEcompiling will NOT result in the same source code...

### Goals and Objectives of RE SW

* facilitate understanding of programs when source code is not available...
  * malware analysis
  * vuln research
  * compiler validaton

## Interface Excercire #1

* ca0d1e....b8dd53
  * open the executable in IDA and use the default loading settings
  * switch between "graph-view" and "text-view"
    * right-click -> Graph/Text view
    *

        <figure><img src=".gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>
  * navigate through the "function windows" and find the main function
  * How many imports and exports does the executable have?
  * Open the Strings windows and configure it to display all string types
  * How many strings has IDA identified?
  * Open the decompiler and jump to the main function
  * Open the segments window - how many sections does the binary have?
  * What are the section names?
  * Close IDA, dont save DB

## Interface Excercire #2

* Enable the line prefixes (address) for the graph view and auto-comments
* Display 6 byte opcodes
* Jump to address 0x00404A00:
  * How many local vars and args does this func have?
    * How many times is this func used in the code?
    * Jump to some of the referenced locations, what can you say about the args?
    * Rename the function to something meaningful
* Go to address 0x005D8028 and define the data as a ASCII string
* Jump to 0x0041...how many bytes does the func have?
* Demangle names, can you see any difference?

### Solution

* ca0d1e....b8dd53
  * Enable the line prefixes (address) for the graph view and auto-comments
    * \-> Options -> General -> Enable them
    *

        <figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>
  * Display 6 byte opcodes
    * \-> Options -> General -> Number of opcode bytes ...
    *

        <figure><img src=".gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>
  * Jump to address 0x00404A00:
    * \->&#x20;
      * How many local vars and args does this func have?
        * How many times is this func used in the code?
        * Jump to some of the referenced locations, what can you say about the args?
          * \-> long args, looks like decryption func, because it has opfuscated strings
        * Rename the function to something meaningful
          * \-> right-click or "N" -> Decrypt...
  * Go to address 0x005D8028 and define the data as a ASCII string
  * Jump to 0x0041
    * right-click -> undefine
      * we can see all the bytes and can count them (16 bytes)
    * right-click or "C"
  * Demangle names, can you see any difference?
    * under functions, there are some functions with weird names
    * Options -> Demangled names
      * we obtain something more user-friendly
      *

          <figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

### Library identification

#### Flirt

* Fast Library Identification and Recognition Technology
* collection of methods to identify common sequences of code, usually part of legitimate libs
* this pattern matching technique sppeds up analysis by eliminating the need of reversing lib func
* how to view/apply FLIRT?
  * go to View ->&#x20;

#### Lumina

<figure><img src=".gitbook/assets/image (4).png" alt=""><figcaption><p>logo</p></figcaption></figure>

* new and centralised technology for identifying common code sequences that is hosted on HexRays servers in cloud
* Lumina server holds metadata about common libs
  * function names, prototypes, comments, operand types...
* Lumina can pull/push metadata from server on demand
* func identified by Lumina are highlited in green
* if you have closed connection, you can make a copy and send it to servers
* embedded by default in IDA Pro (not in freeware)

<figure><img src=".gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

### Debugger

* ideal configuration
  * IDA GUI running on host machine (192.168.0.100)
  * Remote VM debug server (192.168.0.223)
* IDA is known for static analysis

#### Remote Windows debugger

* available only in IDA Pro (not freeware)
* works via the network, composed of server+client app
  * client = IDA -> select the "Remote Windows dbg"
    * checkout the debugger in Debugger options
* server should be copied on network

### Decompiler

* HexRays sells a Decompiler plugin that can generate C-like pseudocode from disassembly
* Open the decompiler view (F5)
* Ease navigation by syncing the Decompiler and Disassembly views
* works for x86 x64 and ARM
* changes made in one of the views will be reflected in the other ones auto
* map duplicate pointers into a single pointer
* add comments to pseudocode

## Debugger Excercise #3

*
