---
description: IDA, instructions, opfuncions
---

# RE debugging

## Static vs. Dynamic

* combine both of them
  * each has pros/cons
* dynamic -> quick idea about malwareÂ´s functionality and to extract some IOCs
  * debugging in VM env (security)
* static -> offers in depth knowledge to reveal more IOCs
* we can create mind map also

## Disassemblers

### IDA

* Interactive disassembler + has also decompiler (additional money for license)
* "The industry standard"
* Supports multiple executable formats and architectures
  * PE, ELF, Mach-O
  * x86, x64, ARM
  * BIOS, UEFI
  * etc
* not good for .NET apps
* Shortcuts
  * G - jump to address
  * X - display references to var/func
  * CTRL+E - display EntryPoints
  * SHIFT+F12 - display strings
  * N - rename var/func
  * ESC - go back
  * M - chooose constant name for var.value
  * R - convert value to ASCII
  * H - convert Hex to Decimal and back

#### Architecture

* Kernel -> Plugins (we can write our own)
* Kernel -> DB (after creating procejt in IDA, it creates about 6 DB files)
  * we can send only DB files to colleagues, not all the project in IDA
* Kernel -> GUI
* Kernel -> Input File Loader
* Kernel -> Processor module

<figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption><p>IDA Pro architecture</p></figcaption></figure>

#### Interface

* First opening IDA Pro -> File loader module
  * displays info about the file, processor type and other options
  * we can leave it as default
* Please confirm window
  * some PEs have also PDB metadata (generated during compiling process)
    * press No since we dont have the PDB file
    * press Yes since it is a Microsoft binary

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption><p>Ida Interface</p></figcaption></figure>

* Views
  * code -> right-click -> synchronize (it colours the given line of code in all views)
  * HexEditor view
  * Structure view
  * Decimpiler view
  * Imports view
  * Strings view
  * Console view
  * Others...

## Introduction

### Programming lang generations

* 1.gen
* 2.gen
* 3.gen
* 4.gen
* 5.gen

### Compilation process

* Compiling -> process of converting source code into object code
* Compiler -> program responsible for this operation
* Compiler breaks the process in 4 stages (+5. loader/execute in OS):
  * preprocessor (hello.cpp file) (hello.i)
    * source code
  * compiler (hello.s)
    * expanded code
  * assembler (hello.obj)
    * assembly code
  * linker (PE file - hello.exe)
    * object code
  * loader/execute (process execution)

### Disassembly and Decompilation process

* RE requires reversing the previously described operations
* compilation is lossy -> we need to determine ourselves the var/func types and names
* each compiler uses different optimizations and translation techniques, thus compilind and DEcompiling will NOT result in the same source code...

### Goals and Objectives of RE SW

* facilitate understanding of programs when source code is not available...
  * malware analysis
  * vuln research
  * compiler validaton

## Interface Excercire

* ca0d1e....b8dd53
  * open the executable in IDA and use the default loading settings
  * switch between "graph-view" and "text-view"
  * navigate through the "function windows" and find the main function
  * How many imports and exports does the executable have?
  * Open the Strings windows and configure it to display all string types
  * How many strings has IDA identified?
  * Open the decompiler and jump to the main function
  * Open the segments window - how many sections does the binary have?
  * What are the section names?
  * Close IDA, dont save DB
