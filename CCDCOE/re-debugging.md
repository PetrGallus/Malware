---
description: IDA, instructions, opfuncions
---

# RE debugging

## Static vs. Dynamic

* combine both of them
  * each has pros/cons
* dynamic -> quick idea about malware´s functionality and to extract some IOCs
  * debugging in VM env (security)
* static -> offers in depth knowledge to reveal more IOCs
* we can create mind map also

## Disassemblers

### IDA

* Interactive disassembler + has also decompiler (additional money for license)
* "The industry standard"
* Supports multiple executable formats and architectures
  * PE, ELF, Mach-O
  * x86, x64, ARM
  * BIOS, UEFI
  * etc
* not good for .NET apps
* doesnt work with YARA
* Shortcuts
  * G - jump to address
  * X - display references to var/func
  * CTRL+E - display EntryPoints
  * SHIFT+F12 - display strings
  * N - rename var/func
  * ESC - go back
  * M - chooose constant name for var.value
  * R - convert value to ASCII
  * H - convert Hex to Decimal and back

#### Architecture

* Kernel -> Plugins (we can write our own)
* Kernel -> DB (after creating procejt in IDA, it creates about 6 DB files)
  * we can send only DB files to colleagues, not all the project in IDA
* Kernel -> GUI
* Kernel -> Input File Loader
* Kernel -> Processor module

<figure><img src=".gitbook/assets/image (2) (1).png" alt=""><figcaption><p>IDA Pro architecture</p></figcaption></figure>

#### Interface

* First opening IDA Pro -> File loader module
  * displays info about the file, processor type and other options
  * we can leave it as default
* Please confirm window
  * some PEs have also PDB metadata (generated during compiling process)
    * press No since we dont have the PDB file
    * press Yes since it is a Microsoft binary

<figure><img src=".gitbook/assets/image (1) (1).png" alt=""><figcaption><p>Ida Interface</p></figcaption></figure>

* Views
  * code -> right-click -> synchronize (it colours the given line of code in all views)
  * HexEditor view
  * Structure view
  * Decimpiler view
  * Imports view
  * Strings view
  * Console view
  * Others...

## Introduction

### Programming language generations

* 1+2 -> Low level
* 3+4+5 -> High level
* 1.gen -> Binary Machine code
  * 1940-1956
  * Can understand only binary code (0/1)
  * Examples: binary digits/bits
* 2.gen -> Assembly code
  * 1956-1963
  * Examples:&#x20;
  * Usage: microprocessors (transistors), kernels, HW drivers
  * PC needs:
    * ASSEMBLER to translate into machine code
* 3.gen -> Block structured code
  * 1964-1971
  * Examples: C, C++, Java, Pascal, FORTRAN, COBOL, JavaScript
  * Upgrade: English-like words, lesser lines of code, can copy the code to another machine
  * PC needs:
    * COMPILER to translate into assembly code&#x20;
    * ASSEMBLER to translate into machine code
* 4.gen -> OOP (Object oriented programming lang)
  * 1971-now
  * Usage: DBs, scripting
  * Examples: Python, SQL, Ruby, Perl
  * Upgrade: Easier to understand, less time for creation, BUT higher memory consumption, poor control over HW
  * PC needs:
    * COMPILER to translate into assembly code&#x20;
    * ASSEMBLER to translate into machine code
* 5.gen -> Natural Language Processing
  * now
  * They have visual tools to develop a program
  * Examples: Prolog, Mercury, OPS5
  * Upgrade: machine can make decisions, easier to use, BUT complex and long code, a lot of HW needed
  * Usage: Deepl, AI

<figure><img src=".gitbook/assets/image (3) (1).png" alt=""><figcaption><p>Programming language hierarchy [<a href="https://medium.com/@ajuatahcodingarena/generations-of-programming-languages-bed30d19ea8e">https://medium.com/@ajuatahcodingarena/generations-of-programming-languages-bed30d19ea8e</a>]</p></figcaption></figure>

#### Hands-on to explain how the libs, instructions, blocks are made

* GCC - vytváření souborů po částech podle parametrů 0-5
  * přibalují se instrukce, knihovny...

### Compilation process

* Compiling -> process of converting source code into object code
* Compiler -> program responsible for this operation
* Compiler breaks the process in 4 stages (+5. loader/execute in OS):
  * preprocessor (hello.cpp file) (hello.i)
    * source code
  * compiler (hello.s)
    * expanded code
  * assembler (hello.obj)
    * assembly code
  * linker (PE file - hello.exe)
    * object code
  * loader/execute (process execution)

### Disassembly and Decompilation process

* RE requires reversing the previously described operations
* compilation is lossy -> we need to determine ourselves the var/func types and names
* each compiler uses different optimizations and translation techniques, thus compilind and DEcompiling will NOT result in the same source code...

### Goals and Objectives of RE SW

* facilitate understanding of programs when source code is not available...
  * malware analysis
  * vuln research
  * compiler validaton

## Interface Excercire #1

* ca0d1e....b8dd53
  * open the executable in IDA and use the default loading settings
  * switch between "graph-view" and "text-view"
    * right-click -> Graph/Text view
    *

        <figure><img src=".gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>
  * navigate through the "function windows" and find the main function
  * How many imports and exports does the executable have?
  * Open the Strings windows and configure it to display all string types
  * How many strings has IDA identified?
  * Open the decompiler and jump to the main function
  * Open the segments window - how many sections does the binary have?
  * What are the section names?
  * Close IDA, dont save DB

## Interface Excercire #2

* Enable the line prefixes (address) for the graph view and auto-comments
* Display 6 byte opcodes
* Jump to address 0x00404A00:
  * How many local vars and args does this func have?
    * How many times is this func used in the code?
    * Jump to some of the referenced locations, what can you say about the args?
    * Rename the function to something meaningful
* Go to address 0x005D8028 and define the data as a ASCII string
* Jump to 0x0041...how many bytes does the func have?
* Demangle names, can you see any difference?

### Solution

* ca0d1e....b8dd53
  * Enable the line prefixes (address) for the graph view and auto-comments
    * \-> Options -> General -> Enable them
    *

        <figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>
  * Display 6 byte opcodes
    * \-> Options -> General -> Number of opcode bytes ...
    *

        <figure><img src=".gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>
  * Jump to address 0x00404A00:
    * \->&#x20;
      * How many local vars and args does this func have?
        * How many times is this func used in the code?
        * Jump to some of the referenced locations, what can you say about the args?
          * \-> long args, looks like decryption func, because it has opfuscated strings
        * Rename the function to something meaningful
          * \-> right-click or "N" -> Decrypt...
  * Go to address 0x005D8028 and define the data as a ASCII string
  * Jump to 0x0041
    * right-click -> undefine
      * we can see all the bytes and can count them (16 bytes)
    * right-click or "C"
  * Demangle names, can you see any difference?
    * under functions, there are some functions with weird names
    * Options -> Demangled names
      * we obtain something more user-friendly
      *

          <figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

## Library identification

### Flirt

* Fast Library Identification and Recognition Technology
* collection of methods to identify common sequences of code, usually part of legitimate libs
* this pattern matching technique sppeds up analysis by eliminating the need of reversing lib func
* how to view/apply FLIRT?
  * go to View ->&#x20;

### Lumina

<figure><img src=".gitbook/assets/image (4).png" alt=""><figcaption><p>logo</p></figcaption></figure>

* new and centralised technology for identifying common code sequences that is hosted on HexRays servers in cloud
* Lumina server holds metadata about common libs
  * function names, prototypes, comments, operand types...
* Lumina can pull/push metadata from server on demand
* func identified by Lumina are highlited in green
* if you have closed connection, you can make a copy and send it to servers
* embedded by default in IDA Pro (not in freeware)

<figure><img src=".gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

## Debugger

* ideal configuration
  * IDA GUI running on host machine (192.168.0.100)
  * Remote VM debug server (192.168.0.223)
* IDA is known for static analysis

### Remote Windows debugger

* available only in IDA Pro (not freeware)
* works via the network, composed of server+client app
  * client = IDA -> select the "Remote Windows dbg"
    * checkout the debugger in Debugger options
* server should be copied on network

## Decompiler

* HexRays sells a Decompiler plugin that can generate C-like pseudocode from disassembly
* Open the decompiler view (F5)
* Ease navigation by syncing the Decompiler and Disassembly views
* works for x86 x64 and ARM
* changes made in one of the views will be reflected in the other ones auto
* map duplicate pointers into a single pointer
* add comments to pseudocode

## Debugger Excercise&#x20;

XXX

## x64dbg Debugger

* two versions
  * x32dbg
  * x64dbg
* Development language: C++, Qt
  * we can write our own plugins via C++

### Interface

* Disassembled code (left+mid)
* CPU registers (right)
* Memory view (down-left)
  * left coloured have been changed by the user
* Stack view (down-right)
* Works with YARA and other open-source libs (IDA doesnt)
  * others: Qt, TitanEngine, Zydis, Yara, Scylla, Jansson, lz4, XEDParse, asmjit and snowman
* Views
  * CPU
  * Log
    * contains console at the bottom
  * Notes
  * Breakpoints
    * we can add the here
    * we can also add a module (for example XXX.dll)
  * Memory Map
    * addresses here are specific for this process (virtual)
    * when we run it in another PC, it takes another addresses according to the hardware...
    * good to take snapshots here...
  * Call Stack
  * SSH
  * Script
  * Symbols
  * Source
  * References
    * when we search for something&#x20;
      * for example: Memory map -> right-click -> search for something -> appears in references
  * Threads
  * Handler -> same like if I wanna open door, I need my hand to open it
    * Handlers are like API for telling blocks of code what to do, how to execute and so on...
    * Handle column is something like ID/index
  * Trace
    * to quickly execute instructions and see the objects
  * ...

## Debugger Exercise #4

<mark style="color:red;">Alert - Ransomware</mark>

* Configure a remote debugging session
* Place a breakpoint on at the EP and 0x004811B3
* Start the debigger and familarise with the UI
* run the code until the 0x004811B3 and step over on instruction
* dump the process using Scylla and fix the imports
* close the debugging session and open the new file in IDA
* use Lumina to pull available metadata
* if available, use the decompiler to analyse parts of the code
* what happens at 0x00401BAB (you can use debugger if necessary)

### Solution

<mark style="color:red;">Alert - Ransomware</mark>

* Configure a remote debugging session
  *
* Place a breakpoint on at the EP and 0x004811B3
  *
* Start the debigger and familarise with the UI
  *
* run the code until the 0x004811B3 and step over on instruction
  *
* dump the process using Scylla and fix the imports
  *
* close the debugging session and open the new file in IDA
  *
* use Lumina to pull available metadata
  *
* if available, use the decompiler to analyse parts of the code
  *
* what happens at 0x00401BAB (you can use debugger if necessary)

Loaders

* Goal: to load and execute payloads in memory
* loaders are stored in the same binary
* Payload delivery methods
  * Injection in remote processes
    * most prevalent method for payload delivery
    * techniques: hollowing, reflective injection, atom bombing, hijacking...
  * Injection in own process
    * creates new htread via CreateThread
    * create new memory Buffer via VirtualAlloc with RWX permission
  * Patch own executable code
  * Live of the Land binaries
* Popular loaders
  * Aurora
  * Zloader
  * SmokeLoader
  * Shellstarter
  * BazarLoader
  * Brushaloader
  * or we can write our own...
* Calling conventins
  *   x64 - Microsoft

      * integer/pointer -> first 4 args go in CPU registers: RCX, RDX, R8, R9
        * floating points -> first 4 args go in CPU registers: XMM0, XMM1, XMM2, XMM3
        * rest of args is pushed in stack

      &#x20;

Excercise #5

* What type of file is it?
  * **DLL** -> difference between DLL and PE is that we cant doubleclick DLL to run it...loader
  * 64-bit file -> we need to run it in 64-bit process
    * 64-bit file file processes are stored in Windows **System32**
      * to execute this DLL we need to load this processes...
        * **RUNDLL32.EXE**
          * **C:\windows\system32\rundll32.exe**
            * we need to change it in setting and restart debugger to load correct processes...
    * 32-bit file processes are stored in Windows Syswow64
      * to execute this DLL we need to load this processes...
        * RUNDLL64EXE
* How many exports does it have?
  * deep dive into the 1st exported func
* What does the subroutine from 0x180004C0B do?
  * what APIs are called at 0x180004C6D and 0x180004C88?
  * determine the strings deobfuscated
    * 0x180004CE2 - 0x180004D1C
    * 0x180004D79 - 0x180004DB7
    * 0x180004CE2 - 0x180004E1A
    * 0x180004CE2 - 0x18000451C
  * What data/value does the variable from 0x18002E530 store?
  * What data type does the subroutine from 0x1800049E4 return?
