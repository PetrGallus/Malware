---
description: IDA, instructions, opfuncions
---

# RE debugging

## Static vs. Dynamic

* combine both of them
  * each has pros/cons
* dynamic -> quick idea about malware´s functionality and to extract some IOCs
  * debugging in VM env (security)
* static -> offers in depth knowledge to reveal more IOCs
* we can create mind map also

## Disassemblers

### IDA

* Interactive disassembler + has also decompiler (additional money for license)
* "The industry standard"
* Supports multiple executable formats and architectures
  * PE, ELF, Mach-O
  * x86, x64, ARM
  * BIOS, UEFI
  * etc
* not good for .NET apps
* doesnt work with YARA
* Shortcuts
  * G - jump to address
  * X - display references to var/func
  * CTRL+E - display EntryPoints
  * SHIFT+F12 - display strings
  * N - rename var/func
  * ESC - go back
  * M - chooose constant name for var.value
  * R - convert value to ASCII
  * H - convert Hex to Decimal and back

#### Architecture

* Kernel -> Plugins (we can write our own)
* Kernel -> DB (after creating procejt in IDA, it creates about 6 DB files)
  * we can send only DB files to colleagues, not all the project in IDA
* Kernel -> GUI
* Kernel -> Input File Loader
* Kernel -> Processor module

<figure><img src=".gitbook/assets/image (2) (1).png" alt=""><figcaption><p>IDA Pro architecture</p></figcaption></figure>

#### Interface

* First opening IDA Pro -> File loader module
  * displays info about the file, processor type and other options
  * we can leave it as default
* Please confirm window
  * some PEs have also PDB metadata (generated during compiling process)
    * press No since we dont have the PDB file
    * press Yes since it is a Microsoft binary

<figure><img src=".gitbook/assets/image (1) (1).png" alt=""><figcaption><p>Ida Interface</p></figcaption></figure>

* Views
  * code -> right-click -> synchronize (it colours the given line of code in all views)
  * HexEditor view
  * Structure view
  * Decimpiler view
  * Imports view
  * Strings view
  * Console view
  * Others...

## Introduction

### Programming language generations

* 1+2 -> Low level
* 3+4+5 -> High level
* 1.gen -> Binary Machine code
  * 1940-1956
  * Can understand only binary code (0/1)
  * Examples: binary digits/bits
* 2.gen -> Assembly code
  * 1956-1963
  * Examples:&#x20;
  * Usage: microprocessors (transistors), kernels, HW drivers
  * PC needs:
    * ASSEMBLER to translate into machine code
* 3.gen -> Block structured code
  * 1964-1971
  * Examples: C, C++, Java, Pascal, FORTRAN, COBOL, JavaScript
  * Upgrade: English-like words, lesser lines of code, can copy the code to another machine
  * PC needs:
    * COMPILER to translate into assembly code&#x20;
    * ASSEMBLER to translate into machine code
* 4.gen -> OOP (Object oriented programming lang)
  * 1971-now
  * Usage: DBs, scripting
  * Examples: Python, SQL, Ruby, Perl
  * Upgrade: Easier to understand, less time for creation, BUT higher memory consumption, poor control over HW
  * PC needs:
    * COMPILER to translate into assembly code&#x20;
    * ASSEMBLER to translate into machine code
* 5.gen -> Natural Language Processing
  * now
  * They have visual tools to develop a program
  * Examples: Prolog, Mercury, OPS5
  * Upgrade: machine can make decisions, easier to use, BUT complex and long code, a lot of HW needed
  * Usage: Deepl, AI

<figure><img src=".gitbook/assets/image (3) (1).png" alt=""><figcaption><p>Programming language hierarchy [<a href="https://medium.com/@ajuatahcodingarena/generations-of-programming-languages-bed30d19ea8e">https://medium.com/@ajuatahcodingarena/generations-of-programming-languages-bed30d19ea8e</a>]</p></figcaption></figure>

#### Hands-on to explain how the libs, instructions, blocks are made

* GCC - vytváření souborů po částech podle parametrů 0-5
  * přibalují se instrukce, knihovny...

### Compilation process

* Compiling -> process of converting source code into object code
* Compiler -> program responsible for this operation
* Compiler breaks the process in 4 stages (+5. loader/execute in OS):
  * preprocessor (hello.cpp file) (hello.i)
    * source code
  * compiler (hello.s)
    * expanded code
  * assembler (hello.obj)
    * assembly code
  * linker (PE file - hello.exe)
    * object code
  * loader/execute (process execution)

### Disassembly and Decompilation process

* RE requires reversing the previously described operations
* compilation is lossy -> we need to determine ourselves the var/func types and names
* each compiler uses different optimizations and translation techniques, thus compilind and DEcompiling will NOT result in the same source code...

### Goals and Objectives of RE SW

* facilitate understanding of programs when source code is not available...
  * malware analysis
  * vuln research
  * compiler validaton

## Interface Excercire #1

* ca0d1e....b8dd53
  * open the executable in IDA and use the default loading settings
  * switch between "graph-view" and "text-view"
    * right-click -> Graph/Text view
    *

        <figure><img src=".gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>
  * navigate through the "function windows" and find the main function
  * How many imports and exports does the executable have?
  * Open the Strings windows and configure it to display all string types
  * How many strings has IDA identified?
  * Open the decompiler and jump to the main function
  * Open the segments window - how many sections does the binary have?
  * What are the section names?
  * Close IDA, dont save DB

## Interface Excercire #2

* Enable the line prefixes (address) for the graph view and auto-comments
* Display 6 byte opcodes
* Jump to address 0x00404A00:
  * How many local vars and args does this func have?
    * How many times is this func used in the code?
    * Jump to some of the referenced locations, what can you say about the args?
    * Rename the function to something meaningful
* Go to address 0x005D8028 and define the data as a ASCII string
* Jump to 0x0041...how many bytes does the func have?
* Demangle names, can you see any difference?

### Solution

* ca0d1e....b8dd53
  * Enable the line prefixes (address) for the graph view and auto-comments
    * \-> Options -> General -> Enable them
    *

        <figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>
  * Display 6 byte opcodes
    * \-> Options -> General -> Number of opcode bytes ...
    *

        <figure><img src=".gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>
  * Jump to address 0x00404A00:
    * \->&#x20;
      * How many local vars and args does this func have?
        * How many times is this func used in the code?
        * Jump to some of the referenced locations, what can you say about the args?
          * \-> long args, looks like decryption func, because it has opfuscated strings
        * Rename the function to something meaningful
          * \-> right-click or "N" -> Decrypt...
  * Go to address 0x005D8028 and define the data as a ASCII string
  * Jump to 0x0041
    * right-click -> undefine
      * we can see all the bytes and can count them (16 bytes)
    * right-click or "C"
  * Demangle names, can you see any difference?
    * under functions, there are some functions with weird names
    * Options -> Demangled names
      * we obtain something more user-friendly
      *

          <figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

## Library identification

### Flirt

* Fast Library Identification and Recognition Technology
* collection of methods to identify common sequences of code, usually part of legitimate libs
* this pattern matching technique sppeds up analysis by eliminating the need of reversing lib func
* how to view/apply FLIRT?
  * go to View ->&#x20;

### Lumina

<figure><img src=".gitbook/assets/image (4).png" alt=""><figcaption><p>logo</p></figcaption></figure>

* new and centralised technology for identifying common code sequences that is hosted on HexRays servers in cloud
* Lumina server holds metadata about common libs
  * function names, prototypes, comments, operand types...
* Lumina can pull/push metadata from server on demand
* func identified by Lumina are highlited in green
* if you have closed connection, you can make a copy and send it to servers
* embedded by default in IDA Pro (not in freeware)

<figure><img src=".gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

## Debugger

* ideal configuration
  * IDA GUI running on host machine (192.168.0.100)
  * Remote VM debug server (192.168.0.223)
* IDA is known for static analysis

### Remote Windows debugger

* available only in IDA Pro (not freeware)
* works via the network, composed of server+client app
  * client = IDA -> select the "Remote Windows dbg"
    * checkout the debugger in Debugger options
* server should be copied on network

## Decompiler

* HexRays sells a Decompiler plugin that can generate C-like pseudocode from disassembly
* Open the decompiler view (F5)
* Ease navigation by syncing the Decompiler and Disassembly views
* works for x86 x64 and ARM
* changes made in one of the views will be reflected in the other ones auto
* map duplicate pointers into a single pointer
* add comments to pseudocode

## Debugger Excercise&#x20;

XXX

## x64dbg Debugger

* two versions
  * x32dbg
  * x64dbg
* Development language: C++, Qt
  * we can write our own plugins via C++

### Interface

* Disassembled code (left+mid)
* CPU registers (right)
* Memory view (down-left)
  * left coloured have been changed by the user
* Stack view (down-right)
* Works with YARA and other open-source libs (IDA doesnt)
  * others: Qt, TitanEngine, Zydis, Yara, Scylla, Jansson, lz4, XEDParse, asmjit and snowman
* Views
  * CPU
  * Log
    * contains console at the bottom
  * Notes
  * Breakpoints
    * we can add the here
    * we can also add a module (for example XXX.dll)
  * Memory Map
    * addresses here are specific for this process (virtual)
    * when we run it in another PC, it takes another addresses according to the hardware...
    * good to take snapshots here...
  * Call Stack
  * SSH
  * Script
  * Symbols
  * Source
  * References
    * when we search for something&#x20;
      * for example: Memory map -> right-click -> search for something -> appears in references
  * Threads
  * Handler -> same like if I wanna open door, I need my hand to open it
    * Handlers are like API for telling blocks of code what to do, how to execute and so on...
    * Handle column is something like ID/index
  * Trace
    * to quickly execute instructions and see the objects
  * ...

## Debugger Exercise #4

<mark style="color:red;">Alert - Ransomware</mark>

* Configure a remote debugging session
* Place a breakpoint on at the EP and 0x004811B3
* Start the debigger and familarise with the UI
* run the code until the 0x004811B3 and step over on instruction
* dump the process using Scylla and fix the imports
* close the debugging session and open the new file in IDA
* use Lumina to pull available metadata
* if available, use the decompiler to analyse parts of the code
* what happens at 0x00401BAB (you can use debugger if necessary)

### Solution

<mark style="color:red;">Alert - Ransomware</mark>

* Configure a remote debugging session
  *
* Place a breakpoint on at the EP and 0x004811B3
  *
* Start the debigger and familarise with the UI
  *
* run the code until the 0x004811B3 and step over on instruction
  *
* dump the process using Scylla and fix the imports
  *
* close the debugging session and open the new file in IDA
  *
* use Lumina to pull available metadata
  *
* if available, use the decompiler to analyse parts of the code
  *
* what happens at 0x00401BAB (you can use debugger if necessary)

Loaders

* Goal: to load and execute payloads in memory
* loaders are stored in the same binary
* Payload delivery methods
  * Injection in remote processes
    * most prevalent method for payload delivery
    * techniques: hollowing, reflective injection, atom bombing, hijacking...
  * Injection in own process
    * creates new htread via CreateThread
    * create new memory Buffer via VirtualAlloc with RWX permission
  * Patch own executable code
  * Live of the Land binaries
* Popular loaders
  * Aurora
  * Zloader
  * SmokeLoader
  * Shellstarter
  * BazarLoader
  * Brushaloader
  * or we can write our own...
* Calling conventins
  *   x64 - Microsoft

      * integer/pointer -> first 4 args go in CPU registers: RCX, RDX, R8, R9
        * floating points -> first 4 args go in CPU registers: XMM0, XMM1, XMM2, XMM3
        * rest of args is pushed in stack

      &#x20;

## Debugger Excercise #5

* What type of file is it?
* How many exports does it have?
  * deep dive into the 1st exported func
* What does the subroutine from 0x180004C0B do?
  * what APIs are called at 0x180004C6D and 0x180004C88?
  * determine the strings deobfuscated
    * 0x180004CE2 - 0x180004D1C
    * 0x180004D79 - 0x180004DB7
    * 0x180004CE2 - 0x180004E1A
    * 0x180004CE2 - 0x18000451C
  * What data/value does the variable from 0x18002E530 store?
  * What data type does the subroutine from 0x1800049E4 return?

### Solution

* <mark style="color:purple;">What type of file is it?</mark>
  * Detect it Easy:
    * PE64 - Compiler is MS Visual C/C++ 2015, Linker is MS Linker DLL64
    * Endianness - LE
    * Mode - 64-bit
    * Arch - AMD64
    * Type - DLL
  * **DLL** -> difference between DLL and PE is that we cant doubleclick DLL to run it...loader
    * 64-bit file -> we need to run it in 64-bit process
      * 64-bit file file processes are stored in Windows **System32**
        * to execute this DLL we need to load this processes...
          * **RUNDLL32.EXE**
            * **C:\windows\system32\rundll32.exe**
              * we need to change it in setting and restart debugger to load correct processes...
      * 32-bit file processes are stored in Windows Syswow64
        * to execute this DLL we need to load this processes...
          * RUNDLL64EXE
* <mark style="color:purple;">How many exports does it have?</mark>
  * IDA Pro -> Exports -> **4** + main entry from DllEntryPoint
    * while opening in IDA - IDA starts disassembling libs for us
    * after opening, we can modify number of opcodes
      * Options -> General -> Number of opcode bytes
  * x64dbg -> Symbols -> malware.dll -> right-side -> **4** Exports + default one (0)
  * but in general -> first three exports share SAME ADDRESS -> actually we have 5 exports of 3 different addresses, so here is not the correct answer
  * <mark style="color:purple;">deep dive into the 1st exported func</mark>
    * Control\_RunDLL
      * creates entrypoint here
      * calls 2 subroutines
      * jumps to 1 subroutine (sub\_18000446B)
* <mark style="color:red;">while opening in x64dbg</mark>
  * ADDRESSES
    * open the file in CFF loader
      * Nt Headers -> Optional Header -> DllCharacteristics -> "Click here" -> UNTICK "DLL can move"
        * it is a protection for the file by default ... now the addresses wont change&#x20;
        * rename it to "malware2.dll
          * it will create new file to disk -> hashes will be different
            * so we will create report to a different file hash...this is only for education purpose
  * CMD PATH
    * change command line path + restart dbg
      * File -> Open -> C:\Windows\System32\rundll32.exe
        * CMD Path (File -> Change command line):
          * "C:\Windows\System32\rundll32.exe" C:\PATH\malware2.dll,Control\_RunDLL (path to file)
            * process path + file path,exported function (obtained from IDA exports view)
        * now we are debugging the process rundll32.exe for 64-bit dlls
          * we can check it in running processes -> x64dbg runs subprocess rundll32.exe
            * we can check in two stages:
              * after opening rundll32.exe
              * after modifying path in command line of x64dbg
      * after modifying x64dbg env, we can create a snapshot of VM
  * BREAK POINTS
    * Breakpoints -> Add DLL breakpoint -> malware2.dll (name of file)
    * RESTART the session, not the whole x64dbg (under the file/view -> refresh button)
      * "Run" x-times to obtain block of code after EntryPoint
* <mark style="color:purple;">What does the subroutine from 0x180004C0B do?</mark>
  * IDA -> "TAB" -> opens pseudocode (or Jump ->jump to pseudocode)
    * Synchronize (right-click -> Synchronize with...)
    * nothing obvious found
  * Label
    * (right-click -> Label -> Label current address)&#x20;
    * subroutine\_encryption
  * Breakpoint
    * right-click -> Breakpoint -> Toggle
  * What it does:
    * starts decrypting the 4 strings and then compares it with command line, if it doesnt find same string in CMD, it wont do anything&#x20;
  * <mark style="color:purple;">what APIs are called at 0x180004C6D and 0x180004C88?</mark>
    * x64dbg -> "RUN" -> we have the addresses from the entry point -> lets find these two
    * FFD0 | call rax | rax:EntryPoint
    * Label
      * (right-click -> Label -> Label current address)&#x20;
      * API\_call1, API\_call2
    * Breakpoint
      * right-click -> Breakpoint -> Toggle
    * Run
      * go to breakpoint of 0x180004C6D
      * Step Into
        * jmp qword ptr ds:\[<\&GetCommandLineW>]
        * **GetCommandLineW**
          * retrieves the command-lne string for the current process
          * return value is a pointer to the command-line string for the current process
      * go to breakpoint of 0x180004C88
      * Step Into
        * jmp qword ptr ds:\[7FFECE8861B0]
        * **CommandLineToArgvW**
          * Parses a Unicode command line string and returns an array of pointers to the command line arguments, along with a count of such arguments, in a way that is similar to the standard C run-time _argv_ and _argc_ values.
          * return value is a pointer to an array of LPWSTR type values (similar to argv). If the func fails, the return value is NULL
            * what is argv?
              * int main(int argc, char\* argv\[])
                * command-line arguments in C
                * argc -> argument Count, integer var represents the number of comand-line args passed to the program. Very useful about the number of args available for processing withing the program
                * argv -> argument Vector, array of strings (char\*) that holds the actual command-line arguments. The first element (argv\[0]) contain the programs name itself,  other ones (argv\[1....argc-1]) hold the user-provided arguments
                *

                    <pre class="language-c"><code class="lang-c">#include &#x3C;stdio.h>
                    <strong>
                    </strong><strong>int main(int argc, char* argv[]) { 
                    </strong>    printf("Number of arguments: %d\n", argc);

                        for (int i = 0; i &#x3C; argc; ++i) {
                            printf("Argument %d: %s\n", i, argv[i]);
                        }

                        return 0;
                    }
                    </code></pre>


  * <mark style="color:purple;">determine the strings deobfuscated</mark>
    * <mark style="color:purple;">0x180004CE2 - 0x180004D1C</mark>
      * Label -> string1
      * 0x180004D0D
        * mov byte ptr ss:\[rsp+rcx+DC],dil
          * rcx -> zero value
          * DC -> offset
          * rsp+rcx+DC (check on the right - CPU registers)
            * rsp -> interesting one, focus on that
              * right-click -> Follow in Dump -> Dump2
                * Step into string1 loop and see the changes
                  * after finishing the loop and jumping out of string1 loop:
                    * **Control\_RunDLL**
    * <mark style="color:purple;">0x180004D79 - 0x180004DB7</mark>
      * Label -> string2
      * same with string1...
      * 0x180004DA5
        * mov byte ptr ss:\[rsp+rcx+C8],dil
          * rcx -> zero value
          * C8 -> offset
          * rsp+rcx+DC (check on the right - CPU registers)
            * rsp -> interesting one, focus on that
              * right-click -> Follow in Dump -> Dump3
                * Step into string2 loop and see the changes
                  * after finishing the loop and jumping out of string1 loop:
                    * **entryPoint**
    * <mark style="color:purple;">0x180004E0B - 0x180004E1A</mark>
      * Label -> string3
      * same with strings above...
      * 0x180004E08
        * add byte ptr ss:\[rsp+C0],dil
          * C0 -> offset
          * rsp -> interesting one, focus on that
            * right-click -> Follow in Dump -> Dump4
              * Step into string3 loop and see the changes
                * after finishing the loop and jumping out of string1 loop:
                  * **InitLib**
    * <mark style="color:purple;">0x180004FF5 - 0x18000501C</mark>
      * Label -> string4
      * same with strings above...
      * 0x18000500F
        * mov byte ptr ss:\[rsp+rdx+44],cl
          * 44 -> offset
          * rdx -> zero value
          * rsp -> interesting one, focus on that
            * right-click -> Follow in Dump -> Dump5
              * Step into string4 loop and see the changes
                * after finishing the loop and jumping out of string1 loop:
                  * **DLLRegistersServer**
    * in general, we obtained from 4 strings:
      * **DLLRegistersServer InitLib entryPoint Control\_RunDLL**
    * to make it faster (to not have to step into every string loop x-times) -> create a kreakpoint after the loop on new line address and check the result in memory dump
  * <mark style="color:purple;">What data/value does the variable from 0x18002E530 store?</mark>
    * IDA
      * Jump (menu) -> Jump to address (G) -> 0x18002E530
        * .data:0x18002E530 byte\_18002E530
          * DATA XREF: entryPoint...
      * Pseudocode (TAB)
        * char: byte\_18002E530
  * <mark style="color:purple;">What data type does the subroutine from 0x1800049E4 return?</mark>
    * x64dbg
      * 0x1800049E4
        * sub rsp,48
    * IDA
      * sub\_1800049E4
        * TAB -> Pseudocode
          * if (!byte\_1B....) -> move with mouse on that -> **CHAR**
          * return \&byte\_.... -> move with mouse on that -> **CHAR**
            * if NOT char -> do something -> return CHAR
